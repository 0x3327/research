<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>3327 Research</title>
<link>https://3327.io/documents/research/index.html</link>
<atom:link href="https://3327.io/documents/research/index.xml" rel="self" type="application/rss+xml"/>
<description></description>
<image>
<url>https://3327.io/logo.png</url>
<title>3327 Research</title>
<link>https://3327.io/documents/research/index.html</link>
<height>38</height>
<width>144</width>
</image>
<generator>quarto-0.9.64</generator>
<lastBuildDate>Sun, 13 Mar 2022 23:00:00 GMT</lastBuildDate>
<item>
  <title>NFT that is bound by time</title>
  <dc:creator>Marija Mijailovic</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-101.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level1">
<h1>Executive Summary</h1>
<p>NFTs have a unique ID and belong to a single wallet. Two standards define what an NFT is and should do: ERC721 and ERC1155, aiming to distinguish each token to be unique. The development of NFT is still in the early stage, and this research shows how NFTs can change their properties. We go through some existing solutions where some events fundamentally affect the NFT, changing its state, properties, or value. We give an overview of those solutions with a desire to cover how they work under the hood and notice potential problems. In the end, are presented possible use cases that open a new door into the NFT word.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>NFTs (Non-Fungible Tokens) reached incredible popularity in 2021 Ryan Browne<sup>1</sup>. Most of created NFTs are static. We collect it, and we hope its market value will increase. In the case of <em>static</em> NFT, it’s characteristic that its properties and data are immutable and recorded on the blockchain, so such NFTs can’t be changed. Otherwise, there are <em>dynamic</em> NFT for which it’s characteristic that properties and data are mutable, often through oracles that trigger events off-chain system or by interaction with on-chain components, for example, smart contracts other NFTs.</p>
<blockquote class="blockquote">
<p>“Dynamic NFTs are the logical next step for the NFT space, allowing unique items to evolve, and sometimes decay. This replicates the ephemeral nature of the real world and potentially gives exceptional value to a collected item because of its current state. NFTs transitioning from being ‘only’ static to being dynamic can be thought of as progressing from 2D to 3D, it enables an immense possibility of use cases.” — Adrien Berthou, Head of Crypto-Native Comms at DoinGud</p>
</blockquote>
</section>
<section id="goals-methodology" class="level1">
<h1>Goals &amp; Methodology</h1>
<p>The goals of this research:</p>
<ul>
<li>Introduce with dynamic NFT</li>
<li>Search for project that make evolvable NFTs</li>
<li>Research how they work, find some leak</li>
<li>Suggest improvements</li>
</ul>
<p>Methodology for accomplishing those goals:</p>
<ul>
<li>Getting under the hood of open source solutions</li>
<li>Testing existing approach</li>
<li>Solidity</li>
</ul>
</section>
<section id="results-discussion" class="level1">
<h1>Results &amp; Discussion</h1>
<p>First of all, let’s briefly review some existing projects:</p>
<ul>
<li><a href="https://ether.cards/">EtherCards</a>
<ul>
<li>EtherCards is a dynamic NFT platform that allows anyone to give a base set of traits and requirements and launch their NFT collection so that the EtherCards team can create unique NFTs. Traits can be discounts, special access rights, connections to real-world events, airdrops, upgrades, and other benefits. The ability to have traits allows the creator to maximize the value of their art. Ether Cards is an integrated ecosystem composed of two major parts. Those are the platform and the Ether Cards (an advanced membership NFT card). Anybody can use the EtherCards platform, but the owner of the EtherCards card has certain privileges. Under the hood, EtherCards integrate Chainlink VRF to provide verifiable randomness on-chain. Chainlink allows developers to read data from any external API and blockchain network and perform off-chain computation. That will enable NFTs to be connected to the external world to trigger real-world events, in a word, to be dynamic.</li>
<li>EtherCards have supported and worked with <a href="https://blog.ether.cards/lamelo-ball-nft/">LaMelo Ball</a>, <a href="https://nfttyson.com/">Mike Tyson</a>, <a href="https://blog.ether.cards/steve-aoki-partners-with-ether-cards-to-produce-new-animated-nft-collection-dominion-x/">Steve Aoki</a> and <a href="https://blog.ether.cards/artist-profile-dirty-robot/">DirtyRobot</a>. In the above collections, all NFTs metadata are stored <code>https://client-metadata.ether.cards</code> on the central server. Within that metadata is a link that points to NFTs image on IPFS. So, inside the smart contract, we store points to metadata JSON URIs to all variants of one NFT. Later, inside <code>tokenURI</code> function with the support of Chainlink return dynamically created URI of NFT, only one variant.</li>
</ul></li>
<li><a href="https://www.loopheads.info/">Loopheads</a>
<ul>
<li>Loopheads is a Loopring ‘Loopring - <span class="nocase">zkRollup Layer2</span> for Trading and Payment’<sup>2</sup> <em>Moody Brains</em> NFT collection, minted on Looprings Layer 2. There are 25 variants for one Loophead avatar(5 different backgrounds and 5 different brain sizes), which one will be displayed depending on the LRC token price using Uniswap Oracles.</li>
<li>All NFT metadata are stored on decentralized storage - IPFS, within that metadata, is a link that sends to NFT’s image on IPFS. So, inside the smart contract, we store points to metadata JSON URIs to all of the Loophead’s variations. When a Loophead NFT is accessed because Loopheads use ERC1155 standard, the Loophead NFT runs the <code>uri</code> function, the start point of dynamic calculation, to show the loophead avatar. The calculation is done with the support of Uniswwap V3 Oracles. That changes parts of the metadata link based on LRC price and returns only one variant.</li>
</ul></li>
<li><a href="https://docs.uniswap.org/protocol/reference/periphery/libraries/NFTDescriptor">Uniswap LP NFT</a>
<ul>
<li>On Uniswap V3 liquidity provider(LP) position is represented as NFT. This NFT shows information about liquidity position. Based on the pool and your parameters selected on the liquidity providing interface. The unique NFT will be minted, representing your position in that specific pool. As the owner of this NFT, you can modify or save the position. The best part of this project is that NFT is SVG generated entirely on-chain. Because of that, it is secure as an image not rely on any other service that is not on the blockchain, and it affects the price of that NFT.</li>
<li>All liquidity parameters for NFT are stored on-chain. Interesting is that SVG generation is done inside a pure function, and it returns base64 encoded metadata from the view function.</li>
<li>When a Uniswap V3 LP NFT is accessed because it uses the ERC721 standard, it runs the <code>tokenURI</code> function, which is the start point that generates SVG from liquidity parameters and returns base64 encoded metadata.</li>
</ul></li>
<li><a href="https://www.aavegotchi.com/">Aavegotchi</a>
<ul>
<li>Aavegotchi is a crypto collectible game. It was developed to provide users with a new blockchain-based game powered by dynamic NFTs. Aavegotchi information such as Aavegotchi name, traits, and SVG files themselves are saved as contract calldata because it is less gas cost than store in contract storage. The fundamental element of Aavegotchi’s game is randomness. Because of that, they use Chainlink VRF. The main idea behind the game is that the more you love your Aavegotchi character, the more rewards it will give you.</li>
<li>To store SVG, we pass one or more SVG images as a string, along with the information of SVG category type(aavegotchi, collaterals, eyeShapes, wearables) and size of passed SVG images. So inside <code>tokenURI</code> we have all NFTs prepared to return only one determined based on real-life events.</li>
</ul></li>
</ul>
<p>You can quickly determine where your NFT is by calling the <code>tokenURI</code> or <code>uri</code> function on the contract, which returns a URI that points to metadata that shows where NFT lives. Above project for NFT storage use:</p>
<ul>
<li>Centralized server</li>
<li>Decentralized storage (IPFS, Filecoin, Arweave)</li>
<li>On-chain storage</li>
</ul>
<p>The problem with the central server is that the possibility for manipulation is vast. The server owner can change the JSON scheme of your NFT whenever he wants.</p>
<p>The problem with IPFS is that there is no defined way of data replication. It just happens depending on the relevance of the content. In addition, the IPFS node can become offline. The problem is that if the relevance of our data is minor, the bigger is chance to lose data. To resolve the issue, Filecoin and Arweave come into play. Filecoin is a solution where we pay some price to store data for a set time. The problem is that we are limited by time, so our data are not stored permanently. Arweave is a solution that incentivizes the nodes to hold data permanently by paying only one fee in the Arweave token and keeping data forever. The most significant leak here is that it all comes down to having one storage layer that is separate from the blockchain and from the NFT itself on which it is located.</p>
<p>When it comes to on-chain storage, the SVG is scalable because it does not rely on pixels to display the image. SVG is used for vector graphics where we can describe shapes and lines mathematically. But, if we want to present a more complex image in this format, we get a massive SVG file, which will lead to a considerable gas cost. Additionally, the worth of mention is <a href="https://eips.ethereum.org/EIPS/eip-2569">EIP-2569</a>.</p>
<ul>
<li>EIP-2569 is an Ethereum improvement proposal to allow a smart contract to save and retrieve an SVG image. Based on that, the two methods contract must have: <code>getTokenImageSvg(uint256) view returns (string memory)</code> and <code>setTokenImageSvg(uint256 tokenId, string memory imagesvg) internal</code>. As we can see, the potential flaw of function <code>setTokenImageSvg</code> as input parameter accepts SVG image string, which can lead to a considerable gas cost in case of complex SVG.</li>
</ul>
<p>There is no obstacle to the realization of any project that would require the evolution of NFT. Everything needed is that our contract overrides the <code>tokenURI</code> or <code>uri</code> function from ERC721 or ERC1155. Therefore, the precondition is that we have prepared all parameters variants for the dynamic generation of potential variants. The project specification itself decides which variants to return within it.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1">  <span class="kw" style="color: #00769E;">function</span> <span class="fu" style="color: #4758AB;">tokenURI</span>(uint256 tokenId) <span class="kw" style="color: #00769E;">public</span> view <span class="fu" style="color: #4758AB;">override</span>(ERC721) <span class="fu" style="color: #4758AB;">returns</span> (string memory) {</span>
<span id="cb1-2">    <span class="pp" style="color: #AD0000;">require</span>(<span class="fu" style="color: #4758AB;">_exists</span>(tokenId))<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-3">    <span class="cf" style="color: #00769E;">return</span> <span class="fu" style="color: #4758AB;">generateDynamicNFT</span>(tokenId)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-4">  }</span></code></pre></div>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1">  <span class="kw" style="color: #00769E;">function</span> <span class="fu" style="color: #4758AB;">uri</span>(uint256 tokenId) <span class="kw" style="color: #00769E;">public</span> view <span class="fu" style="color: #4758AB;">override</span>(ERC1155) <span class="fu" style="color: #4758AB;">returns</span> (string memory) {</span>
<span id="cb2-2">    <span class="pp" style="color: #AD0000;">require</span>(<span class="fu" style="color: #4758AB;">_exists</span>(tokenId))<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-3">    <span class="cf" style="color: #00769E;">return</span> <span class="fu" style="color: #4758AB;">generateDynamicNFT</span>(tokenId)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-4">  }</span></code></pre></div>
<p>Inside <code>generateDynamicNFT</code>, the user defines how and under what conditions NFT to generate, usually using oracles.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>This research has shown that it is possible to change the data and properties of NFTs, and the next evaluation in NFT is moving from static NFTs to dynamic NFTs. With dynamic NTFs, some use cases could be:</p>
<ul>
<li>An NFT ticket that could retain a value after the event is finished can turn as a discount for a related event or, as some bonus, gifts.</li>
<li>Sports NFT cards can evolve, such as updating their player’s stats or having a limited edition of sports event cards if the player got a super score in a match.</li>
<li>Sport NFT cards that receive bonuses or losses based on wins/losses.</li>
<li>Artist NFT cards that change on a daily/monthly based.</li>
<li>NFTs affected by social media/real-life events.</li>
<li>NFTs that affect the real world, where a user can receive a physical item in exchange for NFT.</li>
<li>Kata NFTs were on the users’ progress the Kata NFT will change.</li>
<li>Geometric shape that change as price change</li>
</ul>
<p>The only related problem is about on-chain storage assets. Most NFTs do not store their assets directly on the blockchain because the cost of keeping them on-chain is expensive, as every action and every byte of information we hold on the blockchain has a fee. In addition, the Ethereum blockchain is designed to keep a record of transactions and not to serve as a data warehouse. Second, on-chain geometrical arts can quickly present, but for the more complex SVG files, it is possible to use <em>the bottom-top</em> approach. The idea is to have one zero-based image as a base and then add traits dynamically to the base image. Where will store only characteristics on-chain, and the NFT image is created dynamically. On-chain storage reduces external dependence, increasing reliability, durability, ownership, and decentralization. Keeping assets on-chain has excellent value. Users can rely on the same guarantees of immutability they use to secure property ownership, and the value of such art is more significant. When the asset is being followed on the Ethereum, we also want that asset to be placed on the Ethereum somehow.</p>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-browneTradingNFTsSpiked2022" class="csl-entry">
Browne, Ryan, ‘Trading in NFTs Spiked 21,000% to More Than $17 Billion in 2021, Report Says’, <em>CNBC</em>, 2022 &lt;<a href="https://www.cnbc.com/2022/03/10/trading-in-nfts-spiked-21000percent-to-top-17-billion-in-2021-report.html" class="uri">https://www.cnbc.com/2022/03/10/trading-in-nfts-spiked-21000percent-to-top-17-billion-in-2021-report.html</a>&gt; [accessed 24 March 2022]
</div>
<div id="ref-LoopringZkRollupLayer2" class="csl-entry">
‘Loopring - <span class="nocase">zkRollup Layer2</span> for Trading and Payment’, <em>Loopring</em> &lt;<a href="https://loopring.org/#/" class="uri">https://loopring.org/#/</a>&gt; [accessed 24 March 2022]
</div>
</div></section><section class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>‘Trading in NFTs Spiked 21,000% to More Than $17 Billion in 2021, Report Says’, <em>CNBC</em>, 2022 &lt;&lt;https://www.cnbc.com/2022/03/10/trading-in-nfts-spiked-21000percent-to-top-17-billion-in-2021-report.html&gt;&gt; [accessed 24 March 2022].↩︎</p></li>
<li id="fn2"><p><em>Loopring</em> &lt;&lt;https://loopring.org/#/&gt;&gt; [accessed 24 March 2022].↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-101.gfm.html</guid>
  <pubDate>Sun, 13 Mar 2022 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Detect NFT Wash Trading</title>
  <dc:creator>Milos Bojinovic</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-90.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level1">
<h1>Executive Summary</h1>
<p>With the monthly trading volume of the <strong>Non-Fungible Token (NFT)</strong> marketplace <a href="https://opensea.io">OpenSea</a> reaching 5 billion dollars in January 2022<sup>1</sup> it is clear that NFTs are gaining popularity and with that grows the importance of having a transparent trading activity.</p>
<p><strong>Wash trading</strong> is a form of market manipulation where a single entity or a group of colluding entities buy and sell the same asset with the goal of feeding the marketplace misleading information<sup>2</sup>. There are at least two possible benefits to wash trading, the first being that a single asset can be wash traded multiple times, continually increasing the price, thus making the asset appear more sought after than it actually is. This chain of wash trades is broken when an unsuspecting victim buys the asset. The second potential benefit is that the trading can be incentivized by the platform, with rewards being tied to the volume traded. Trading rewards can, at least for a limited time period, be higher than the fees, which makes this process worthwhile.</p>
<p>In the case of NFTs, wash trading is additionally enabled by the associated user anonymity. One single entity can control a large number of addresses without a way of reliably determining who is behind them. Those addresses, however, need to be somehow funded to make them usable, which leads to a money trail that can be followed to detect connections between them and to flag suspicious NFT trades.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Currently, only <a href="https://nansen.ai">Nansen</a>, a blockchain analytics platform that requires a paid subscription, offers a feature called “Wash Trading Filter” where users can see the metrics (volume, average price, etc.) for an NFT collection with and without the filter but cannot browse through the individual NFTs. Another drawback is that Nansen doesn’t disclose how the filter works, and so the question of why some trades were flagged remains.</p>
<p>Data on the blockchain is public, but it is hard to extract specific pieces of information from it. Detecting if a particular NFT was wash traded would require collecting every single trade that was made on all of the marketplaces and checking if the addresses involved in it are connected in some way. This data would need to be safely stored and effectively parsed to enable answering if any arbitrarily chosen NFT has been wash traded. The detection algorithm should also provide adequate reasoning on why a specific trade has been flagged. Developing and publicly disclosing the inner workings of such an algorithm would add more transparency to NFT trading, but it would inevitably lead to the creation of more intricate patterns that would not get caught if the algorithm is not regularly updated.</p>
</section>
<section id="goals-methodology" class="level1">
<h1>Goals &amp; Methodology</h1>
<p><strong>The goals</strong> of this research are to :</p>
<ul>
<li>define what transaction patterns classify as a wash trade</li>
<li>develop ways of extracting the necessary information needed for the detection:
<ul>
<li>trades on two of the largest NFT marketplaces (OpenSea and <a href="https://looksrare.org/">LooksRare</a>)</li>
<li>Ether transfers for each of the accounts involved in the trade</li>
</ul></li>
<li>serve as a starting point for the creation of detection algorithms</li>
</ul>
<p><strong>Methodology</strong> for accomplishing those goals consists of</p>
<ul>
<li>taking into account only Ethereum’s on-chain transactions when discussing ways a wash trade can be made</li>
<li>using <a href="https://docs.etherscan.io/">Etherscan</a> and <a href="https://docs.alchemy.com/alchemy/">Alchemy</a> APIs to enable the data collection process</li>
<li>using Python programming language for the implementation part</li>
</ul>
</section>
<section id="results-discussion" class="level1">
<h1>Results &amp; Discussion</h1>
<section id="wash-trading-patterns" class="level3">
<h3 class="anchored" data-anchor-id="wash-trading-patterns">Wash Trading Patterns</h3>
<p>The explanation for the diagrams used in this paper is the following:</p>
<ul>
<li>White circles with a letter inside them are addresses that are considered</li>
<li>Address can be connected with multiple lines</li>
<li>The line that has the <strong>NFT</strong> written on it signals that those two addresses were involved in an NFT trade</li>
<li>The line containing a number <strong>n</strong> on it signals that exists an Ether transfer trail between those addresses through <strong>n</strong> intermediaries
<ul>
<li>if <strong>n</strong> = 0 that is a direct transfer</li>
<li>if <strong>n</strong> = 1 there is a transfer trail involving one intermediary address</li>
</ul></li>
<li>Lines with an arrow care about the direction of a transfer and point to the new owner’s address</li>
<li>Lines without an arrow do not care about the direction</li>
</ul>
<p>Shown on <em>Figure 1</em> there are two “meta-patterns” that this paper considers.</p>
<center>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/assets/ERFC-90/images/meta-patterns.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
<p><em>Figure 1 - Considered Meta-patterns</em></p>
</center>
<p>Meta-patterns can be expanded into specific patterns that care about the direction of those transfers (<em>Figure 2</em>). While some patterns may be more suspicious than others, all of them can be used for the purpose of wash trading. For example <em>pattern 2.2</em> can mean that after making a wash trade and selling the NFT to someone else, addresses <strong>A</strong> and <strong>B</strong> send all of their funds to address <strong>C</strong>.</p>
<center>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/assets/ERFC-90/images/expanded-patterns.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
<p><em>Figure 2 - Expanded patterns</em></p>
</center>
<p>The reason that all of these patterns do not take the time order of transfers into account is that it doesn’t matter - they need to detect only the connections between addresses.</p>
</section>
<section id="collecting-and-parsing-of-data" class="level2">
<h2 class="anchored" data-anchor-id="collecting-and-parsing-of-data">Collecting and Parsing of Data</h2>
<p>This research takes into account only trades of NFTs that follow the ERC721 standard. The same principles can be applied to the trades involving the ERC1155 standard, with the only difference being the collection and parsing of trades.</p>
<p>When an NFT trade is executed, the ERC721 compliant contracts emit a <strong>Transfer event</strong> that contains three fields: previous owner, new owner, and the token id. Using the combination of Etherscan and Alchemy APIs, it is possible to get all the events that were emitted by the transaction and to extract the needed event based on its topic along with all of its fields.</p>
<p>Not every Transfer event corresponds to a trade, so there needs to be an extra processing step that will eliminate all transfers that were not made through a marketplace. To do this, one needs to go through all of the marketplace’s contract’s transactions and select only those that have the right <strong>methodID</strong>.</p>
<p>After the seller’s (previous owner’s) and buyer’s (new owner’s) addresses are known, the last step is collecting and parsing of all of their transactions searching for Ether transfers and all the addresses they have interacted with - in this paper referred to as “associates”.</p>
</section>
<section id="wash-trading-detectors" class="level2">
<h2 class="anchored" data-anchor-id="wash-trading-detectors">Wash Trading Detectors</h2>
<p>Having a set of all of the buyer’s and seller’s associates enables the creation of <strong>Wash Trading Detectors (WTD)</strong>. This paper proposes and implements two basic algorithms:</p>
<ul>
<li><strong>WTD0</strong> that detects a direct transfer by checking if the seller’s address belongs to the set of buyer’s associates</li>
<li><strong>WTD1*</strong> that detects a set of common associates that are Externally Owned Accounts (EOAs)</li>
</ul>
<p>*WTD1 is incomplete because the detected common associate can be a Centralized Exchange’s (CEX) address which would give a false positive. The only way to make the WTD1 fully functional is to manually keep a list of all the addresses that should be ignored.</p>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<p>Using the proposed ways of getting the data and reasoning on it, it is possible to extract suspicious wash trading patterns, flag those trades, and perform an analysis of the results. The code shown bellow is capable of getting the count of detected wash trades performed through a marketplace in a given block range :</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: null;">import</span> utils</span>
<span id="cb1-2"></span>
<span id="cb1-3"><span class="kw" style="color: #00769E;">def</span> run(contract, methodIds, start_block, end_block):</span>
<span id="cb1-4">    <span class="co" style="color: #5E5E5E;">'''Detects potential Wash trades for a marketplace's contract'''</span></span>
<span id="cb1-5"></span>
<span id="cb1-6">    transactions <span class="op" style="color: #5E5E5E;">=</span> utils.get_all_transactions(</span>
<span id="cb1-7">        contract,</span>
<span id="cb1-8">        start_block,</span>
<span id="cb1-9">        end_block</span>
<span id="cb1-10">    )</span>
<span id="cb1-11"></span>
<span id="cb1-12">    wtd0_count, wtd1_count, total <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">0</span>, <span class="dv" style="color: #AD0000;">0</span>, <span class="dv" style="color: #AD0000;">0</span></span>
<span id="cb1-13"></span>
<span id="cb1-14">    <span class="cf" style="color: #00769E;">for</span>  tx <span class="kw" style="color: #00769E;">in</span> transactions:</span>
<span id="cb1-15"></span>
<span id="cb1-16">        <span class="cf" style="color: #00769E;">if</span> tx[<span class="st" style="color: #20794D;">'input'</span>][:<span class="dv" style="color: #AD0000;">10</span>] <span class="kw" style="color: #00769E;">in</span> methodIds:</span>
<span id="cb1-17"></span>
<span id="cb1-18">            status, logs <span class="op" style="color: #5E5E5E;">=</span> utils.get_logs(tx[<span class="st" style="color: #20794D;">'hash'</span>])</span>
<span id="cb1-19"></span>
<span id="cb1-20">            <span class="cf" style="color: #00769E;">if</span> status <span class="op" style="color: #5E5E5E;">!=</span> <span class="dv" style="color: #AD0000;">1</span>: <span class="co" style="color: #5E5E5E;"># Reverted transaction</span></span>
<span id="cb1-21">                <span class="cf" style="color: #00769E;">continue</span></span>
<span id="cb1-22"></span>
<span id="cb1-23">            nft_contract, token_id, A, B <span class="op" style="color: #5E5E5E;">=</span> utils.parse_logs(logs)</span>
<span id="cb1-24"></span>
<span id="cb1-25">            <span class="cf" style="color: #00769E;">if</span> A <span class="op" style="color: #5E5E5E;">==</span> <span class="va" style="color: #111111;">None</span> <span class="kw" style="color: #00769E;">or</span> B <span class="op" style="color: #5E5E5E;">==</span> <span class="va" style="color: #111111;">None</span>: <span class="co" style="color: #5E5E5E;"># not a standard ERC721</span></span>
<span id="cb1-26">                <span class="cf" style="color: #00769E;">continue</span></span>
<span id="cb1-27"></span>
<span id="cb1-28">            associates_A <span class="op" style="color: #5E5E5E;">=</span> utils.get_associates(A)</span>
<span id="cb1-29">            associates_B <span class="op" style="color: #5E5E5E;">=</span> utils.get_associates(B)</span>
<span id="cb1-30"></span>
<span id="cb1-31">            wtd0_count <span class="op" style="color: #5E5E5E;">+=</span> <span class="bu" style="color: null;">int</span>(</span>
<span id="cb1-32">                utils.wtd0(A, B, associates_A, associates_B)</span>
<span id="cb1-33">            )</span>
<span id="cb1-34">            wtd1_count <span class="op" style="color: #5E5E5E;">+=</span> <span class="bu" style="color: null;">int</span>(</span>
<span id="cb1-35">                <span class="bu" style="color: null;">len</span>(utils.wtd1(A, B, associates_A, associates_B)) <span class="op" style="color: #5E5E5E;">&gt;</span> <span class="dv" style="color: #AD0000;">0</span></span>
<span id="cb1-36">            )</span>
<span id="cb1-37"></span>
<span id="cb1-38">            total <span class="op" style="color: #5E5E5E;">+=</span> <span class="dv" style="color: #AD0000;">1</span></span>
<span id="cb1-39"></span>
<span id="cb1-40">    <span class="cf" style="color: #00769E;">return</span> (wtd0_count, wtd1_count, total)</span></code></pre></div>
<p>The <code>run</code> function consists of getting all transaction data for a marketplace’s contract starting from the <code>start_block</code> up to the <code>end_block</code> and considering only those that are in the provided list of <code>methodIds</code>. These transactions are then parsed, and values are extracted that will be passed to the <code>utils.wtd0</code> and <code>utils.wtd1</code> functions which will perform detection.</p>
<p>For the full implementation of all of the used helper methods from <code>utils</code> module see Appendix A.</p>
<section id="example" class="level3">
<h3 class="anchored" data-anchor-id="example">Example</h3>
<p>For example, let us take the <a href="https://etherscan.io/address/0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b">OpenSea’s Wyvern V1 contract</a> and pass three different block ranges. The <code>['0xab834bab']</code> argument corresponds to the <code>methodID</code> of the contract’s method that gets called when there is a trade.</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1">WYVERN_V1 <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">'0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b'</span></span>
<span id="cb2-2"></span>
<span id="cb2-3">ranges <span class="op" style="color: #5E5E5E;">=</span> [</span>
<span id="cb2-4">    [<span class="dv" style="color: #AD0000;">6652089</span>, <span class="dv" style="color: #AD0000;">6652239</span>],</span>
<span id="cb2-5">    [<span class="dv" style="color: #AD0000;">7486211</span>, <span class="dv" style="color: #AD0000;">7486311</span>],</span>
<span id="cb2-6">    [<span class="dv" style="color: #AD0000;">7704798</span>, <span class="dv" style="color: #AD0000;">7704898</span>],</span>
<span id="cb2-7">]</span>
<span id="cb2-8"></span>
<span id="cb2-9"><span class="cf" style="color: #00769E;">for</span> start_block, end_block <span class="kw" style="color: #00769E;">in</span> ranges:</span>
<span id="cb2-10"></span>
<span id="cb2-11">    <span class="bu" style="color: null;">print</span>(run(WYVERN_V1, [<span class="st" style="color: #20794D;">'0xab834bab'</span>], start_block, end_block))</span></code></pre></div>
<p>From the total of <strong>23</strong> trades that were made during the provided ranges :</p>
<ul>
<li>WTD0 flags <strong>8</strong> trades</li>
<li>WTD1 flags <strong>11**</strong> trades</li>
</ul>
<p>**WTD1 returns a list of associate addresses; these lists were manually checked through Etherscan to see if they belong to a CEX. The list of ignored addresses is available in Appendix B.</p>
</section>
<section id="implications" class="level3">
<h3 class="anchored" data-anchor-id="implications">Implications</h3>
<p>The sample size of <strong>23</strong> is too small to discuss how the reported numbers relate to all of the NFT trades since the marketplace’s contract deployment. The code itself can, however, serve as a starting point for the development of a service capable of extracting the data from all of the NFT marketplaces since their creation. In that data lies the key to answering not only what trades are a wash trade but also who performed them, how many times was an address linked to a wash trade, whether one NFT has been wash traded multiple times, etc. Such a service would need to effectively manage its resources such as the collection of data and the computation needed in the detection - in the example above, set of associates is always computed from scratch (there is no storing of the result and checking if those values have already been computed). The full specification for the development of this service is out of the scope of this paper and should be a topic of a separate research.</p>
<section id="complex-patterns" class="level4">
<h4 class="anchored" data-anchor-id="complex-patterns">Complex Patterns</h4>
<p>Due to current non-negligible transaction fees on Ethereum and the fact that not many people are deeply looking into each trade, it is unlikely that there are complex patterns present in NFT wash trading. As the fees get lower and as the adoption grows, it’s almost certain that they will emerge. On the <em>Figure 3</em> is shown one pattern that could be used in the process of wash trading.</p>
<center>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/assets/ERFC-90/images/complex-pattern.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
<p><em>Figure 3 - Complex pattern</em></p>
</center>
<p>There are two NFT wash trades present (marked by the black and blue colored arrows). The sequence of transfers is the following:</p>
<ol type="1">
<li><strong>A</strong> finances <strong>B</strong> and <strong>C</strong> through 3 and 2 intermediaries, respectively</li>
<li><strong>B</strong> finances <strong>D</strong> through 3 intermediaries</li>
<li><strong>D</strong> buys an NFT from some non-associated address</li>
<li><strong>D</strong> sells the NFT to <strong>C</strong></li>
<li><strong>D</strong> sends the funds to <strong>B</strong> through the same 3 intermediaries that were used before</li>
<li><strong>B</strong> finances <strong>E</strong> through 2 intermediaries</li>
<li><strong>E</strong> buys the NFT from <strong>C</strong></li>
</ol>
<p>After the last step, <strong>E</strong> can sell the NFT to an unsuspecting victim. It is important to note that addresses used do not have to be discarded after each wash trade - i.e.&nbsp;<strong>B</strong> can be used just for routing of the funds. Furthermore, a malevolent entity can inflate the prices of not just a single NFT but for a complete collection, making it look like the collection is very popular, which attracts victims.</p>
</section>
</section>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>This research shows that it is possible to flag a specific trade as being a wash trade. The proposed algorithms can serve as a starting point in this process. To flag a specific NFT as being wash traded there would need to exist a list of all the trades of that NFT. This could be done via a service that would enable the users to browse the history of trades of any NFT on every marketplace and see all of the connections between the addresses that once owned it. If the service is built and popularized while keeping its inner workings public, the malevolent parties would try to evade detection which would lead to the need to constantly improve the algorithm.</p>
</section>
<section id="appendices" class="level1">
<h1>Appendices</h1>
<section id="appendix-a" class="level2">
<h2 class="anchored" data-anchor-id="appendix-a">Appendix A</h2>
<p>Implementation of the <code>utils</code> module.</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: null;">import</span> time, json, requests</span>
<span id="cb3-2"><span class="im" style="color: null;">from</span> web3 <span class="im" style="color: null;">import</span> Web3</span>
<span id="cb3-3"></span>
<span id="cb3-4">config <span class="op" style="color: #5E5E5E;">=</span> {</span>
<span id="cb3-5">    <span class="st" style="color: #20794D;">"alchemy-url"</span> : <span class="st" style="color: #20794D;">""</span>,</span>
<span id="cb3-6">    <span class="st" style="color: #20794D;">"etherscan-api-key"</span>: <span class="st" style="color: #20794D;">""</span>,</span>
<span id="cb3-7">}</span>
<span id="cb3-8"></span>
<span id="cb3-9">web3 <span class="op" style="color: #5E5E5E;">=</span> Web3(Web3.HTTPProvider(config[<span class="st" style="color: #20794D;">'alchemy-url'</span>]))</span>
<span id="cb3-10"></span>
<span id="cb3-11"><span class="kw" style="color: #00769E;">def</span> get_all_transactions(address, start_block <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">0</span>, end_block <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">19999999</span>):</span>
<span id="cb3-12">    <span class="co" style="color: #5E5E5E;">'''Gets all transactions using Etherscan API for the provided address'''</span></span>
<span id="cb3-13">    transactions <span class="op" style="color: #5E5E5E;">=</span> []</span>
<span id="cb3-14"></span>
<span id="cb3-15">    <span class="cf" style="color: #00769E;">while</span> <span class="va" style="color: #111111;">True</span>:</span>
<span id="cb3-16">        time.sleep(<span class="dv" style="color: #AD0000;">5</span>)</span>
<span id="cb3-17">        result <span class="op" style="color: #5E5E5E;">=</span> requests.get(</span>
<span id="cb3-18">            <span class="st" style="color: #20794D;">'https://api.etherscan.io/api?module=account&amp;action=txlist'</span> <span class="op" style="color: #5E5E5E;">+</span></span>
<span id="cb3-19">            <span class="ss" style="color: #20794D;">f'&amp;address=</span><span class="sc" style="color: #5E5E5E;">{</span>address<span class="sc" style="color: #5E5E5E;">}</span><span class="ss" style="color: #20794D;">'</span> <span class="op" style="color: #5E5E5E;">+</span></span>
<span id="cb3-20">            <span class="ss" style="color: #20794D;">f'&amp;startblock=</span><span class="sc" style="color: #5E5E5E;">{</span>start_block<span class="sc" style="color: #5E5E5E;">}</span><span class="ss" style="color: #20794D;">'</span> <span class="op" style="color: #5E5E5E;">+</span></span>
<span id="cb3-21">            <span class="ss" style="color: #20794D;">f'&amp;endblock=</span><span class="sc" style="color: #5E5E5E;">{</span>end_block<span class="sc" style="color: #5E5E5E;">}</span><span class="ss" style="color: #20794D;">'</span> <span class="op" style="color: #5E5E5E;">+</span></span>
<span id="cb3-22">            <span class="ss" style="color: #20794D;">f'&amp;offset=</span><span class="sc" style="color: #5E5E5E;">{</span><span class="dv" style="color: #AD0000;">1_000</span><span class="sc" style="color: #5E5E5E;">}</span><span class="ss" style="color: #20794D;">'</span> <span class="op" style="color: #5E5E5E;">+</span></span>
<span id="cb3-23">            <span class="ss" style="color: #20794D;">f'&amp;sort=</span><span class="sc" style="color: #5E5E5E;">{</span><span class="st" style="color: #20794D;">"asc"</span><span class="sc" style="color: #5E5E5E;">}</span><span class="ss" style="color: #20794D;">'</span> <span class="op" style="color: #5E5E5E;">+</span></span>
<span id="cb3-24">            <span class="ss" style="color: #20794D;">f'apikey=</span><span class="sc" style="color: #5E5E5E;">{</span>config[<span class="st" style="color: #20794D;">"etherscan-api-key"</span>]<span class="sc" style="color: #5E5E5E;">}</span><span class="ss" style="color: #20794D;">'</span></span>
<span id="cb3-25">        ).json()[<span class="st" style="color: #20794D;">'result'</span>]</span>
<span id="cb3-26"></span>
<span id="cb3-27">        transactions <span class="op" style="color: #5E5E5E;">+=</span> result</span>
<span id="cb3-28"></span>
<span id="cb3-29">        <span class="cf" style="color: #00769E;">if</span> <span class="bu" style="color: null;">len</span>(result) <span class="op" style="color: #5E5E5E;">&lt;</span> <span class="dv" style="color: #AD0000;">1_000</span>:</span>
<span id="cb3-30">            <span class="cf" style="color: #00769E;">break</span></span>
<span id="cb3-31"></span>
<span id="cb3-32">        start_block <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">int</span>(result[<span class="op" style="color: #5E5E5E;">-</span><span class="dv" style="color: #AD0000;">1</span>][<span class="st" style="color: #20794D;">"blockNumber"</span>]) <span class="op" style="color: #5E5E5E;">+</span> <span class="dv" style="color: #AD0000;">1</span></span>
<span id="cb3-33"></span>
<span id="cb3-34"></span>
<span id="cb3-35">    <span class="cf" style="color: #00769E;">return</span> transactions</span>
<span id="cb3-36"></span>
<span id="cb3-37"><span class="kw" style="color: #00769E;">def</span> is_EOA(address):</span>
<span id="cb3-38">    <span class="co" style="color: #5E5E5E;">'''Returns true if the address belongs to an Externally Owned Account'''</span></span>
<span id="cb3-39"></span>
<span id="cb3-40">    <span class="cf" style="color: #00769E;">try</span>:</span>
<span id="cb3-41">        _address <span class="op" style="color: #5E5E5E;">=</span> Web3.toChecksumAddress(address)</span>
<span id="cb3-42">        <span class="cf" style="color: #00769E;">return</span> web3.eth.getCode(_address) <span class="op" style="color: #5E5E5E;">==</span> <span class="st" style="color: #20794D;">b""</span></span>
<span id="cb3-43">    <span class="cf" style="color: #00769E;">except</span>:</span>
<span id="cb3-44">        <span class="cf" style="color: #00769E;">return</span> <span class="va" style="color: #111111;">False</span></span>
<span id="cb3-45"></span>
<span id="cb3-46"><span class="kw" style="color: #00769E;">def</span> get_associates(address):</span>
<span id="cb3-47">    <span class="co" style="color: #5E5E5E;">'''Returns a set of all account with which the provided addresses interacted with'''</span></span>
<span id="cb3-48"></span>
<span id="cb3-49">    transactions <span class="op" style="color: #5E5E5E;">=</span> get_all_transactions(address)</span>
<span id="cb3-50"></span>
<span id="cb3-51">    associates <span class="op" style="color: #5E5E5E;">=</span> <span class="bu" style="color: null;">set</span>()</span>
<span id="cb3-52">    <span class="cf" style="color: #00769E;">for</span> tx <span class="kw" style="color: #00769E;">in</span> transactions:</span>
<span id="cb3-53">        <span class="cf" style="color: #00769E;">if</span> tx[<span class="st" style="color: #20794D;">'from'</span>] <span class="op" style="color: #5E5E5E;">!=</span> address:</span>
<span id="cb3-54">            associates.update([tx[<span class="st" style="color: #20794D;">'from'</span>]])</span>
<span id="cb3-55">        <span class="cf" style="color: #00769E;">if</span> tx[<span class="st" style="color: #20794D;">'to'</span>] <span class="op" style="color: #5E5E5E;">!=</span> address:</span>
<span id="cb3-56">            associates.update([tx[<span class="st" style="color: #20794D;">'to'</span>]])</span>
<span id="cb3-57"></span>
<span id="cb3-58">    <span class="cf" style="color: #00769E;">return</span> associates</span>
<span id="cb3-59"></span>
<span id="cb3-60"><span class="kw" style="color: #00769E;">def</span> get_logs(tx_hash):</span>
<span id="cb3-61">    <span class="co" style="color: #5E5E5E;">'''Gets the logs from the transaction receipt of the tx_hash'''</span></span>
<span id="cb3-62"></span>
<span id="cb3-63">    tx_receipt <span class="op" style="color: #5E5E5E;">=</span> web3.eth.get_transaction_receipt(tx_hash)</span>
<span id="cb3-64"></span>
<span id="cb3-65">    <span class="cf" style="color: #00769E;">return</span> tx_receipt[<span class="st" style="color: #20794D;">'status'</span>], tx_receipt[<span class="st" style="color: #20794D;">'logs'</span>]</span>
<span id="cb3-66"></span>
<span id="cb3-67"><span class="kw" style="color: #00769E;">def</span> parse_logs(logs):</span>
<span id="cb3-68">    <span class="co" style="color: #5E5E5E;">'''Returns the NFT contract's address, token id and addresses involved in the trade'''</span></span>
<span id="cb3-69"></span>
<span id="cb3-70">    TRANSFER_TOPIC <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"</span></span>
<span id="cb3-71">    WRAPPED_ETH <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"</span></span>
<span id="cb3-72"></span>
<span id="cb3-73">    nft_contracts, token_ids, _from, _to <span class="op" style="color: #5E5E5E;">=</span> [], [], <span class="va" style="color: #111111;">None</span>, <span class="va" style="color: #111111;">None</span></span>
<span id="cb3-74"></span>
<span id="cb3-75">    <span class="cf" style="color: #00769E;">for</span> ev <span class="kw" style="color: #00769E;">in</span> logs:</span>
<span id="cb3-76"></span>
<span id="cb3-77">        <span class="cf" style="color: #00769E;">if</span> TRANSFER_TOPIC <span class="op" style="color: #5E5E5E;">==</span> ev[<span class="st" style="color: #20794D;">"topics"</span>][<span class="dv" style="color: #AD0000;">0</span>].<span class="bu" style="color: null;">hex</span>() <span class="kw" style="color: #00769E;">and</span> ev[<span class="st" style="color: #20794D;">"address"</span>] <span class="op" style="color: #5E5E5E;">!=</span> WRAPPED_ETH:</span>
<span id="cb3-78"></span>
<span id="cb3-79">            nft_contracts.append(ev[<span class="st" style="color: #20794D;">"address"</span>])</span>
<span id="cb3-80"></span>
<span id="cb3-81">            bytecode <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">""</span>.join([x.<span class="bu" style="color: null;">hex</span>() <span class="cf" style="color: #00769E;">for</span> x <span class="kw" style="color: #00769E;">in</span> ev[<span class="st" style="color: #20794D;">"topics"</span>]]) <span class="op" style="color: #5E5E5E;">+</span> <span class="st" style="color: #20794D;">""</span>.join(ev[<span class="st" style="color: #20794D;">"data"</span>])</span>
<span id="cb3-82">            _from <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">"0x"</span> <span class="op" style="color: #5E5E5E;">+</span> bytecode[<span class="dv" style="color: #AD0000;">66</span> : <span class="dv" style="color: #AD0000;">66</span> <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">2</span>][<span class="op" style="color: #5E5E5E;">-</span><span class="dv" style="color: #AD0000;">40</span>:]</span>
<span id="cb3-83">            _to <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">"0x"</span> <span class="op" style="color: #5E5E5E;">+</span> bytecode[<span class="dv" style="color: #AD0000;">66</span> <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">2</span> : <span class="dv" style="color: #AD0000;">66</span> <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">3</span>][<span class="op" style="color: #5E5E5E;">-</span><span class="dv" style="color: #AD0000;">40</span>:]</span>
<span id="cb3-84">            token_ids.append(<span class="bu" style="color: null;">int</span>(bytecode[<span class="dv" style="color: #AD0000;">66</span> <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">3</span> : <span class="dv" style="color: #AD0000;">66</span> <span class="op" style="color: #5E5E5E;">*</span> <span class="dv" style="color: #AD0000;">4</span>][<span class="dv" style="color: #AD0000;">2</span>:<span class="dv" style="color: #AD0000;">66</span>], base<span class="op" style="color: #5E5E5E;">=</span><span class="dv" style="color: #AD0000;">16</span>))</span>
<span id="cb3-85"></span>
<span id="cb3-86">    <span class="cf" style="color: #00769E;">return</span> nft_contracts, token_ids, _from, _to</span>
<span id="cb3-87"></span>
<span id="cb3-88"></span>
<span id="cb3-89"><span class="kw" style="color: #00769E;">def</span> wtd0(A, B, associates_A, associates_B):</span>
<span id="cb3-90">    <span class="co" style="color: #5E5E5E;">'''WTD0 implementation'''</span></span>
<span id="cb3-91"></span>
<span id="cb3-92">    <span class="cf" style="color: #00769E;">return</span> (A <span class="kw" style="color: #00769E;">in</span> associates_B) <span class="kw" style="color: #00769E;">or</span> (B <span class="kw" style="color: #00769E;">in</span> associates_A)</span>
<span id="cb3-93"></span>
<span id="cb3-94"><span class="kw" style="color: #00769E;">def</span> wtd1(A, B, associates_A, associates_B):</span>
<span id="cb3-95">    <span class="co" style="color: #5E5E5E;">'''WTD1 implementation'''</span></span>
<span id="cb3-96"></span>
<span id="cb3-97">    EOA_associates <span class="op" style="color: #5E5E5E;">=</span> []</span>
<span id="cb3-98"></span>
<span id="cb3-99">    common_associates <span class="op" style="color: #5E5E5E;">=</span> associates_A.intersection(associates_B)</span>
<span id="cb3-100">    <span class="cf" style="color: #00769E;">for</span> ca <span class="kw" style="color: #00769E;">in</span> common_associates:</span>
<span id="cb3-101">        <span class="cf" style="color: #00769E;">if</span> is_EOA(ca):</span>
<span id="cb3-102">            EOA_associates.append(ca)</span>
<span id="cb3-103"></span>
<span id="cb3-104">    <span class="cf" style="color: #00769E;">return</span> EOA_associates</span></code></pre></div>
</section>
<section id="appendix-b" class="level2">
<h2 class="anchored" data-anchor-id="appendix-b">Appendix B</h2>
<p>Following is the list of all the addresses that were ignored by WTD1 due to the fact that they belong to CEXs</p>
<center>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Address</th>
<th style="text-align: center;">CEX</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0x564286362092d8e7936f0549571a803b203aaced</td>
<td style="text-align: center;">Binance3</td>
</tr>
<tr class="even">
<td style="text-align: center;">0x59a5208b32e627891c389ebafc644145224006e8</td>
<td style="text-align: center;">HitBTC2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x56eddb7aa87536c09ccc2793473599fd21a8b17f</td>
<td style="text-align: center;">Binance17</td>
</tr>
<tr class="even">
<td style="text-align: center;">0xeb2629a2734e272bcc07bda959863f316f4bd4cf</td>
<td style="text-align: center;">Coinbase6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0xd551234ae421e3bcba99a0da6d736074f22192ff</td>
<td style="text-align: center;">Binance2</td>
</tr>
<tr class="even">
<td style="text-align: center;">0xb5d85cbf7cb3ee0d56b3bb207d5fc4b82f43f511</td>
<td style="text-align: center;">Coinbase5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x0681d8db095565fe8a346fa0277bffde9c0edbbf</td>
<td style="text-align: center;">Binance4</td>
</tr>
<tr class="even">
<td style="text-align: center;">0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be</td>
<td style="text-align: center;">Binance</td>
</tr>
</tbody>
</table>
</center>
</section>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>


</section>

<div id="quarto-appendix" class="default"><section class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p><strong>haywardOpenSeaHitsRecord2022?</strong>↩︎</p></li>
<li id="fn2"><p><strong>WashTradingDefinition?</strong>↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-90.gfm.html</guid>
  <pubDate>Fri, 11 Mar 2022 23:00:00 GMT</pubDate>
  <media:content url="https://3327.io//documents/research/assets/ERFC-90/images/meta-patterns.png" medium="image" type="image/png" height="35" width="144"/>
</item>
<item>
  <title>Crypto Insurance - Current state, problems and possibilities of creating new products</title>
  <dc:creator>Aleksandar Damjanovic</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-91.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level1">
<h1>Executive Summary</h1>
<p>In this paper we covered 5 of the main players in DeFi insurance market in order to determine the products offered, the problems with these products, the way the claims are handled and the possibilty of creating new insurance protocols. Initially we were not familiar with this field and the effort needed for creating these products, so we conducted this explorative research.</p>
<p>After the research we came to these conclusions:</p>
<ol type="1">
<li>In creating these kind of products there needs to be significant effort both in developing and inital investment. Protocols covered utilize Advisory Boards of insurance experts in order to create their products.</li>
<li>State regulation is a big factor in insurance in order to protect the policyholders from malicious insurance offerers. This can be a problem, depending on the states’ attitude towards cryptocurrency.</li>
<li>Handling claims is often left to the community incentivizing just behavior by staking.</li>
<li>Collecting adequate capital initially is also one of the major problems.</li>
<li>Protocols with less staked pools have higher premiums in most cases which shows us that the risk assessment is usually hard to do with new protocols.</li>
<li>There is a limited cover capacity.</li>
<li>Usually there is no cross-chain coverage which limits the protection capability of DeFi protocols on other chains.</li>
<li>Lack of protection diversity: most products offered are limited when compared to the broad coverage of risk types in the traditional insurance market.</li>
<li>Insuring real world Events is almost non-existent. Etherisc offers 2 products using Oracles but our assumption is that there is still no market need for this kind of products thus there is not much movement in this direction. However utilizing Oracles in traditional products is an interesting thing and we think should be looked more into.</li>
</ol>
<p>However, if You would like to go deeper to understand how these protocols work we recommend reading the entire paper.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>In this paper we will be exploring the current state and problems of the decentralized/crypto insurance field with an emphasis to exploring the types of insurance offered, how are claims assessed, processed and finally paid out to the insured in a decentralized way.</p>
<p>Before we go further in the paper we will be shortly covering some insurance basics with a goal of reader’s better understanding of this paper and insurance’s importance in Decentralized Finance (DeFi). Considering Insurance is one of the oldest ways of dispersing risk over many individual units there could be many potential use cases for using this kind of mechanism in Web3, not just for the insurance of loss. Alas, this paper will be covering the current state and problems of Insurance and we will leave the potential cases for discussion.</p>
<p><strong>If you are already familiar with insurance terms you can continue to the Goals &amp; Methodology paragraph.</strong></p>
<section id="what-is-insurance" class="level2">
<h2 class="anchored" data-anchor-id="what-is-insurance">What is Insurance?</h2>
<p>Insurance has a long history, there are claims that it was created around 2000 BC in Babylon, merchant receiving a loan paid the lender extra money in exchange for exemption of loan payment if the merchant’s shipment were stolen. Hovewer, the importance of insurance field cannot be presented without a mention of London’s Lloyd’s. In the 17th century, a London coffeehouse was a meeting place for people seeking marine cargo protection and people willing to take those risks in exchange for premium. The coffeeshop now is the world famous Lloyds. A sheet of cargo and ship information would be filled and the individuals who accepted that risk would sign with their names under it’s description.<sup>1</sup> That brings us to a first term in insurance <strong>underwriting</strong>.</p>
<ul>
<li><p>Underwriting is risk accessment process to determine whether to accept or reject the risk we will come into contact with this term a lot in the later paragraphs.</p></li>
<li><p>As we previously mentioned the point of insurance is to <strong>transfer and share risks.</strong></p></li>
<li><p>The individuals or companies that would like to transfer risk to other parties by paying a certain fee (<strong>premium</strong>) are called <strong>insured</strong>. The reason why the insured avoid the risk is because the loss is too volatile to bear.</p></li>
<li><p>The party that accepts such risks and and associated fee (<strong>premium</strong>) is the <strong>insurer</strong>. Insurers are not averse to exposing themselves to the same risks as insured because of something called <strong>pooling</strong> and the law of <strong>large numbers</strong>. The essence of pooling risk is to <strong>spread losses of the few over the entire group.</strong> The law of large numbers states that <strong>the greater the number of exposures the more closely will the actual results approach to the expected average value</strong></p></li>
</ul>
</section>
<section id="benefits-of-insurance-and-the-nature-of-insurance" class="level2">
<h2 class="anchored" data-anchor-id="benefits-of-insurance-and-the-nature-of-insurance">Benefits of Insurance and the nature of Insurance</h2>
<p>Insurance allows the insureds to “trade” the risk of loss for the certainty of smaller payments. As a result this ensured the stable cash flow since there are no extreme losses, and if they happen, they are covered by the insurance. As a result of this “stability” provided by insurance there is less need for governments assistance which saves public resources.<sup>2</sup></p>
<table>
<colgroup>
<col style="width: 19%">
<col style="width: 20%">
<col style="width: 25%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th>Application</th>
<th>Underwriting</th>
<th>Policy Issuance</th>
<th>Claim if a loss occurs</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p><em>Figure 1: The process of issuing insurance</em></p>
<ul>
<li>The application for insurance often starts with quoting process where the amount to be paid in premiums are estimated according to the risk the client would like to manage. After the application the underwriting process occurs.</li>
<li>Underwriter evaluates the information of the application and then accepts and then “fine-tunes” the policy using the rating tables from the actuaries. Actuaries calculate premiums, in DeFi, this is done in a different way, more words on that in the later paragraphs.</li>
<li>After the underwriter accepts the application the policy is issued.</li>
<li>If a loss occures the claims department examines the claim and asks the insured for the proof of loss before they pay the insured amount. The payment depends on the amount of damage suffered and the decision of the claim department.</li>
</ul>
<p>The big part of insurance also is its regulation. Insurance is one of the most actively regulated fields, especially after the financial crisis in 2008. The regulation aims to ensure solvency of the insurers. One of the ways the state regulates Insurance companies is limiting their investment tacticts and portfolio allocation , in other words they don’t let them invest in risky assets which is de-facto the norm in cryptocurrency investments. This is one of the first issues encountered if we were to cooporate with existing insurance companies or create our own protocol that is regulated.<sup>3</sup></p>
</section>
</section>
<section id="goals-methodology" class="level1">
<h1>Goals &amp; Methodology</h1>
<p>The goal of this research is to explore:</p>
<ol type="1">
<li>The current state of DeFi Insurance and Insurance with cryptocurrency.</li>
<li>The process of applying, policy issuing and insurance claiming in a decentralized way of the main competitors in this market</li>
<li>The problems present with this kind of products.</li>
<li>Possibility of insuring material goods with cryptocurrency.</li>
</ol>
<p>Approach to this research will primarily be reading the whitepapers of covered protocols and documentation, discord discussions with staff and reading the reports of other researchers we find online.</p>
<p>Answers to the questions above will give us an insight into this field of DeFi and will provide us with better of understanding of insurance in general for creating potential products if we decide to go into that direction. Considering the effort needed to create this kind of products this short explorative research is conducted.</p>
<p>Approach to this will be explorative one as previously mentioned. We will start with presenting the main competitors in this field and we will analyze their proccesses. Extra attention will be paid to the biggest competitors. Afterwards the problems of these products with cryptocurrency will be presented.</p>
</section>
<section id="results-discussion" class="level1">
<h1>Results &amp; Discussion</h1>
<section id="the-current-state-of-defi-insurance-and-insurance-with-cryptocurrency-and-insurance-processes" class="level2">
<h2 class="anchored" data-anchor-id="the-current-state-of-defi-insurance-and-insurance-with-cryptocurrency-and-insurance-processes">The current state of DeFi Insurance and Insurance with cryptocurrency and insurance processes</h2>
<p>When it comes to crypto-insurance with traditional insurers the market is non-existent, because of the regulation, lack of awareness and the lack of crypto adoption among general public. That’s why we will be covering DeFi insurance field.</p>
<p>DeFi Insurance refers to buying coverage against losses cause by events in Decentralized Finance. With various hacks and exploits over the years the need for insuring users from the results of these events emerged. Contrary to the layman’s belief DeFi Insurance field is big and growing with different protocols emerging in it. However only 2% of all DeFi value is insured at the moment.<sup>4</sup></p>
<p>Main protections offered is capital protection against protocol hack/exploit risk, smart contract failures or stablecoin crashes. The premium user pays for a cover depends on the type of the cover, insurance provider and the duration of the cover.</p>
<p>The Decentralized part in this type of Insurance is that anybody can act as a coverage provider, which supports the initial writers assumption. They become providers by locking up capital in a capital pool of the insurance protocol thus providing needed liquidity. As coverage providers they choose for which protocols or events they want to provide coverage, for example: If they are certain that a protocol is safe from exploits they will prefer providing liquidity to the pool that covers that event.</p>
<p>Another big part of DeFi Insurance is verifying claims. This is often done by the Insurance protocol’s community. Considering the nature of insurance and pooling of risk and collecting coverage from providers they are often assembled as DAOs (Decentralized Autonomous Organizations). This means that governance token holders participate in verifying claims. There are several ways of doing that and we will be covering it in the next paragraph.</p>
<section id="main-players-in-this-market" class="level3">
<h3 class="anchored" data-anchor-id="main-players-in-this-market">Main players in this market</h3>
<p>The 5 main competitors in DeFi insurance are:</p>
<ol type="1">
<li>Nexus Mutual</li>
<li>Bridge Mutual</li>
<li>InsurAce</li>
<li>Nsure</li>
<li>Etherisc</li>
</ol>
<p><em>Note: There are more insurance protocols but in order to keep this research a short overview we will showcase five</em></p>
<p>We will be covering them in detail to explore how they work and the type of products offered.</p>
</section>
<section id="nexus-mutual" class="level3">
<h3 class="anchored" data-anchor-id="nexus-mutual">Nexus mutual</h3>
<p>Nexus mutual is an Ethereum-based platform that offers insurance products led by community management and financials. Nexus mutual is set up as a DAO. Nexus offers three kinds of products:</p>
<ul>
<li>Protection against failures in any protocol used by users yield bearing token (Ethereum only)</li>
<li>Protection against failures in the individual protocol user has funds in, on any chain, but not in other protocols it uses.</li>
<li>Protection against hacks and halted withdrawals on exchanges or custodial wallets<sup>5</sup></li>
</ul>
<p>Simply put, Nexus cover protects against loss of funds, not loss of value, except in the Yield Token Cover. In the Yield Token Cover Nexus <em>may</em> pay a claim if:</p>
<ul>
<li>During the cover period the face value of the covered token and the market value of the covered token differ in price by more than 10% for a continuous period of four hours or more; and</li>
<li>The Covered Member contributes to the mutual, one unit of face value of the covered token in exchange for 0.90 units of cover amount they wish to claim; and</li>
<li>The Covered Member redeems their claim payment during the cover period or within 14 days of the cover period ending.</li>
</ul>
<p>Nexus does not provide Cover where the covered tokens and the cover amount are not denominated in the same refference currency. Nexus also doesn’t provide cover for any material goods loss.</p>
<p><strong>Claim assessing process:</strong></p>
<ul>
<li>All Covered members for a particular covered token will be assessed together for each claim event; and</li>
<li>The face value of the covered token immediately prior to the claim event shall be set as part of the claims assessment process; and</li>
<li>Following a successful claim vote all Covered Members will be able to contribute their covered tokens and redeem their claim payment on a proportional basis up to the cover amount.<sup>6</sup></li>
</ul>
<p>We will not cover the other 2 products into great detail, as they are pretty straight forward. More info on them can be found here: https://nexusmutual.gitbook.io/docs/welcome/faq/cover-products</p>
<p>All protocols and custodial accounts can be covered by the platform provided that <strong>risk assesesors</strong> staked enough value against them. Risk Assessors (experienced auditors, capital providers) can stake value in the form of NXM token, thereby vouching for the security of the protocol/custodian and dropping the price of the cover. NXM can be unstaked at any time subject to a 30-day withdrawal period. When cover is subsequently sold on a protocol or custodian, Risk Assessors earn proportional rewards in NXM equivalent to 50% of the cover premium. If a claim is accepted and a payout occurs, Risk Assessors staked against the protocol/custodian will have their staked NXM burnt on a proportional basis to facilitate the payout of the cover amount. This may result in a Risk Assessor having some or all of their NXM staked against the protocol/custodian burnt to provide capital for the payout of the claim.</p>
<p>Cover becomes available through one of two ways:</p>
<ol type="1">
<li><p>When Risk Assessors stake NXM against a protocol, custodian or cover product more cover is made available. The mutual places limits on the amount of cover to protect the mutual from being too exposed to any single risk. There are two limits a <strong>Specific Risk Limit</strong> and a <strong>Global Capacity Limit</strong>.</p>
<ol type="1">
<li><p><strong>Specific Risk limit</strong> means capacity on any particular risk is limited by the amount of staking on that risk. If there is no staking the mutual cannot offer any cover. Specific Risk limit is equal to : <strong>capacity factor x net_staked_NXM</strong> .</p></li>
<li><p><strong>Global Capacity Limit</strong> is based on the financial resources of the Mutual and is there to ensure the mutual is not overly exposed to any particular risk, regardless of how much is staked. <strong>Global Capacity Limit = Minimum Capital Requirement In ETH (MCReth) x 20%</strong></p></li>
</ol></li>
<li><p>As cover policies expire cover becomes available. User can check Nexus Tracker for info on cover expiry.<sup>7</sup></p></li>
</ol>
<p><strong>Membership issue regarding privacy</strong></p>
<p>Membership in Nexus requires a one-off membership fee of 0.0020 ETH (~$5.50). However, to become a member users need to verify their identity following their Know Your Customer process. They also cannot accept members from 17 countries, Serbia included, thus limiting the usage of the mutual.</p>
<p><strong>Transparency</strong></p>
<p>All deployed contracts of Nexus Mutual can be found here: https://api.nexusmutual.io/version-data/</p>
<p>All info regarding cover, staking and claims approvals/denies can be found here: https://nexustracker.io/</p>
<p><strong>How are Cover purchases taken care of by Nexus?</strong></p>
<p>Users specify which smart contract address they want cover for. They specify the cover amount , currency (ETH or DAI) and Cover Period. Quote will be generated and they need to make the transaction with Metamask. Users can currently pay with ETH, DAI or NXM (nexus mutual tokens). Cover Holders can submit a claim for material loss that occured within the cover period. They can also submit a claim up to 35 days after expiry. <strong>A loss that ocurs after cover policy is ended won’t be covered</strong></p>
<p><strong>How are claims taken care of?</strong></p>
<p>Claims are filed by submission. Members must provide cryptographic evidence of the loss (proof of loss) and their claim is later assessed by Claim Assessors by voting. Assessors are financially incentivised to take a longer-term view as they are required to lockup a stake. This stake is then burned if there is evidence of fradulent voting, which is addressed by Advisory Board. Advisory board consists of five members of founding team of the Nexus Mutual and insurance industry experts. They are said to have :</p>
<ul>
<li>Technical Expertise on Smart Contract Security and blockchain</li>
<li>Technical Expertise on Insurance and Mutuals</li>
<li>General Expertise</li>
</ul>
<p>Advisory board is there to provide techniqual guidance to the members of the mutual as well as to exercize the emergency functions if they are required.</p>
<p>This proposes a question: How do they keep the Advisory Board “in check” with Nexus’s decentralization principles?</p>
<p>Nexus does that by enabling members to kick-vote the Advisory Board members that they think are working maliciously. Board member can be replaced by another member if the membership base agrees. These proposals cannot be interfered with by the existing Advisory Board.</p>
</section>
<section id="bridge-mutual" class="level3">
<h3 class="anchored" data-anchor-id="bridge-mutual">Bridge Mutual</h3>
<p>Bridge Mutual has a similar business model as Nexus Mutual (DAO model). They provide coverage for smart contracts, stablecoins and other services. Bridge allows users to purchase coverage, provide coverage in exchange for yield, vote on policy claims and their payouts. We will not go into great detail as there are various similarities with Nexus Mutual to avoid repeating ourselves.</p>
<p><strong>The main difference between Bridge and Nexus Mutual is that that Bridge doesn’t check customer’s ID and is available for residents all countries</strong></p>
<p>Any user on the platform can create any pool for any project as because the system is permissionless by design.</p>
<ul>
<li>Initial capital (USDT) must be put into the Project Coverage Pool by the user that is creating the pool.</li>
<li>That project can create incentives for coverage providers to provide coverage to their pool by depositing any number of Token into its designated Shield Mining pool which gets distributed to Coverage Providers alongside the typical yield.</li>
</ul>
<p>Coverage Provider examines the risk of providing Coverage Capital to the Project’s Coverage Pool. When they provide capital they are de-facto telling users that they are sure in the security and stability of the project. They recieve yield from the users purchasing policies and the BMI(Bridge Mutual) token staking. When coverage providers supply capital to the coverage pool they receive a token (bmi(project name)Cover) representing their share in the capital within this capital pool. Coverage providers can then stake those tokens in the bmiCover Staking Contract pool to get additional BMI rewards. They also recieve a BMINFT Bond that represent the amount of for example DAI staked in Cover Staking Contract pool. These NFT Bonds are tradable on any NFT marketplace. The purpose of these NFT bonds is to give the user a way out of their position without removing DAI from the ecosystem. When the Coverage Provider sells his NFT he also transfers the ownership of the staked bmiDAIx.</p>
<p>Policy Holder pays a premium for Coverage to protect against the Coverage Event that could affect the insured Project and cause them to lose funds. The total cost of the Premium is split : 80% to coverage 20% to the Reinsurance Pool. They can buy cover for minimum of 1 week and maximum of 52 weeks. Three factors determine the price of cover (premium):</p>
<ol type="1">
<li>The utilization ratio of the pool (ratio between cover bought and cover provided, pools that have higher utilization ratio are riskier and more expensive)</li>
<li>Duration of the cover</li>
<li>Amount of cover which user wants to buy</li>
</ol>
<p>The Reinsurance pool consists of protocol owned funds that are used to provide liquidity to Coverage Pools. The reinsurance pool is funded through 20% of all premiums paid as mentioned above.</p>
<p>The Capital Pool aggregates USDT from the Coverage Pools and provides additional revenue to the protocol. Capital Pool sends USDT to yield generating platforms they deem to have low risk. We coulnd’t find exactly what those platforms are. This is a similarity with classic insurance companies which are limited in what way they invest their funds.</p>
<p><strong>Proving a loss</strong></p>
<p>Policy holders should submit any or all of the following:</p>
<ol type="1">
<li>Transaction IDs proving that Policy Holder’s wallet deposited assets into the protocol and transaction IDs of the Coverable Event</li>
<li>Posts from Protocol team, or an auditing team confirming that there was an exploit and providing additional information</li>
<li>A description of the Coverable Event</li>
<li>If the address affected was not the same address that purchased coverage, any evidence that proves the Policy Holder is the bonafide owner of the address that suffered a Permanent Loss.</li>
</ol>
<p>They also need to deposit 1% of the claim’s value in BMI to prevent spam claims. If the claim is valid, USDT is issued to the Claimant. If a claim is denied they can try again by depositing 1% again.</p>
<p>A successful claim can only recieve up to the policy’s maximum coverable amount. If the DAO determines that the loss suffered was less then the maximum coverable amount, policy owners may recieve less funds. The DAO is incentivized to pay the claimant the exact amount that was lost.</p>
<p><strong>Voting process</strong></p>
<p>Votes for claim approval are anonymous and any user holding vBMI can vote. Voters can wote on multiple Claims before submitting them in a batch send. This is done to save time and gas. Only users that vote in the majority are rewarded with BMI for voting. Users that vote in the minority can lose “reputation” which decreases voting power. If there is a large diference in voting yes or no (80% to 20%) users that voted no will lose a portion of their stake.</p>
<p><img src="https://3327.io/documents/research/posts/https:/1853607048-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-McJ-rdy5DzkSkdXp6VM%2F-MdWXc4-iyw6LOwtZ90R%2F-MdWfiqPXhasXmnJESvb%2Fimage.png?alt=media&amp;token=11a1af05-bbde-4941-be28-3274fac85146" style="height: 400px; width:600px;"></p>
<p><em>Figure 2. High Level Overview of Bridge Mutual’s Mechanism</em></p>
</section>
<section id="insureace.io" class="level3">
<h3 class="anchored" data-anchor-id="insureace.io">InsureAce.io</h3>
<p>InsurAce.io is a multi-chain mutual insurance protocol created in April 2021. It offers products that cover 100+ protocols, 3 CEX and 1 IDO platform. Currently they are depoloyed on Ethereum, Binance Smart Chain, Polygon and Avalanche. InsurAce hasn’t yet adopted the DAO governance mechanism, although they are working on it.</p>
<p>Current state of Insurace.io (Capital pool size, Active cover amount, Capital Ratios etc ) can be found here: https://app.insurace.io/Data/Insurance</p>
<p>This protocols has 4 unique selling propositions :</p>
<ol type="1">
<li>“0” Premium - Which means that the premiums are lower for their products. Their team designed portfolio-centric products to embrace risk diversification, developed models to optimize the cover cost. They did so by using advisors that are experts in the Insurance domain.</li>
<li>Enriched Product Line - InsurAce.io also offers products that covers non-Ethereum DeFi protocols.
<ol type="1">
<li>Types of protocols and smart contract systems covered:
<ol type="1">
<li>Lending Protocols</li>
<li>Decentralized Exchanges</li>
<li>Derivative (e.g.&nbsp;Synthetix, Nexus Mutual)</li>
<li>Asset (e.g.&nbsp;Badger, RenVM)</li>
</ol></li>
</ol></li>
<li>SCR Mining - The participants earn $INSUR tokens by staking into the mining pool. The mutual capitals injected through staking will be managed with rigorous risk control models to adjust the Solvency Capital Requirement (SCR) dynamically and use the secured free capital for investment to control the mining speed accordingly.</li>
<li>InsurAce tries to combat the low investment returns. Nexus mutual offers capital return to their providers from the premiums paid by users which is low compared to the yield on Compound and Aave. This problem makes users prefer putting their funds elsewhere, instead of the Insurance Protocol. Insurace combats this with offering users:
<ol type="1">
<li>Option to invest directly in the investment product depending on their risk aversion</li>
<li>Option to stake in the mutual pool and get the investment carries and $INSUR tokens as rewards</li>
<li>Shares of the premium income</li>
</ol></li>
</ol>
<p>InsurAce is operates similarly like the traditional insurance company using the insurance arm and the investment arm.</p>
<p>“The insurance arm maintains reserve pools which maintain the solvency for claim coverage based on risk exposure. The investment arm maintains investment pools that generate carry to subsidize claims and attracts investors with risk appetite. The free capital in the insurance capital pool can be placed into the investment pool to gain a higher yield, while the insurance arm will protect the investment activities. Meanwhile, the investment arm’s yield will complement the premium on the insurance side and reduce the cover cost for customers.”<sup>8</sup></p>
<p><strong>Pricing model</strong></p>
<p>When it comes to before mentioned protocols they rely heavily on the value staked on individual protocols: the higher value staked the lower the premium will be priced. InsurAce tries to combat this with adopting the new actuary-based pricing model to mitigate this in order to assess the expected loss of insurance products fairly, reduce costs and enhance capability.</p>
<p>“The model’s main inputs are the number/amount of claims and number/amount of exposures in a given time period, which will be used for selecting and training two separate models - the frequency model and the severity model. Frequency modeling produces a model that calibrates the probability of a given number of losses occurring during a specific period, while severity modeling produces the distribution of loss amounts and sets the level of deductible and limit of the coverage amount.” These models are then combined to solve aggregate loss. After that the decided aggregate loss is incorporated into the risk factors of protocols and the premiums are then calculated. The model’s parameters rely on historical data to devise and validate. They plan on taking this further with new Machine Learning methodologies.</p>
<p><strong>Capital model</strong></p>
<p>InsurAce’s capital model refers to EIOPA’s Solvency II, this regime is used for insurance and reinsurance in the European Union. It sets requirements needed for insurance products in order to protect policyholdes and beneficiaries.</p>
<p>“Solvency II is an economic risk-based approach that should assess the”overall solvency” of insurance and reinsurance undertakings through quantitative and qualitative measures. Under Solvency II, the undertaking’s solvency requirements are determined based on their risk profiles and how such risks are managed, providing the right incentives for sound risk management practices and securing enhanced transparency.”</p>
<p>Solvency II has different tiers of which the SCR (Solvency Capital Requirement) and MCR (Minimum Capital Requirement) are the two most important ones.</p>
<p>“The SCR is the capital required to ensure that the insurance company will be able to meet its obligations over the next 12 months with a probability of at least 99.5%, while MCR represents the threshold to correspond to an 85% probability of adequacy over 12 months and is bound between 25% and 45% of the SCR. For supervisory purposes, the SCR and MCR can be regarded as”soft” and “hard” floors.”</p>
<p>InsurAce uses SCR to calculate the minimum requirement funds set aside to pay all the potential claims considering all quantifiable risks. SCR is calculated with the following inputs:</p>
<ol type="1">
<li>All the active covers</li>
<li>All the outstanding claims</li>
<li>The potential incurred but not reported claims</li>
<li>The market currency shock risk</li>
<li>The non-life premium &amp; reserve, lapse and catastrophe risks</li>
<li>The potential operational risk</li>
</ol>
<p><code>SCR% = Capital Pool Size / SCR</code></p>
<p>A high ratio means the insurance company is financially strong with sufficient available funds to cover potential claims and other risks so the company is less likely to be insolvent . <strong>The lowest acceptable ratio is 100%.</strong></p>
<p>InsurAce also offers information of their Capital Efficiency ratio which shows the company’s current success in deploying capital.</p>
<p><code>CER% = Active Cover Amount / Capital Pool Size</code></p>
<p>A high ratio means the insurance company is increasing the productivity of its assets to generate income. Desired ratio is between 100% and 300%.</p>
<p><strong>Risk Assesment by InsurAce.io</strong></p>
<p>InsuraAce’s Advisory Board performs a preliminary risk assesment on the new protocols at first. InsurAce will also work with auditing firms if there is extra complexity or challenges. After that Advisory Board provides a report and rates the protocol 1 to 5. After they rate it protocol will go through the community risk assesment. Members who participate in the assesment get INSUR tokens as incentive.</p>
<p><strong>Claims Assesment by InsurAce.io</strong></p>
<p><img src="https://3327.io/documents/research/posts/https:/2557507273-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-MOAoQ0O7ivP8Rd-tXSY-887967055%2Fuploads%2FLlbDnXivNTRl7Zwnlcxn%2Fclaim_assess_eng_v2.0%20(1).png?alt=media&amp;token=c9eccb8d-1707-47b5-adc6-dc09f7fc439c" style="height: 700px; width:550px;"></p>
<p><em>Figure 3: InsureAce’s Claim Assesment process</em></p>
<p>This diagram shows us the whole system of claims Assesment in a clear way. The main difference is the inclusion of the Advisory board members which consists of various industry experts including the CTO of InsurAce.</p>
<p>“$INSUR token holders can stake the $INSUR tokens to become the community Claim Assessor. Claim Assessor will be entitled to the right to vote in each claim assessment and earn $INSUR tokens as reward if their votes match with the voting result. During each voting session, the more tokens the user stake, the more voting tickets they will get (* capped at 5% of the total votes), and the more rewards they will receive.”</p>
</section>
<section id="nsure" class="level3">
<h3 class="anchored" data-anchor-id="nsure">Nsure</h3>
<p>Nsure was targeted to be a platform for users to trade risks borrowing the operation model of previously mentioned Lloyds London. With Nsure information is transparent and users are allowed not only to be outsorcing risk but also to become risk takers, capital providers, governance actors and auditors of the system.</p>
<p>More data on Nsure performance can be found here: https://app.nsure.network/#/cover/my</p>
<p><strong>Product</strong></p>
<p>Nsure offers Smart contract cover like previously mentioned protocols. The coverage and exclusions are identical so we will not go into great detail. More info can be found at: https://docs.nsure.network/nsure-network/docs/nsure-smart-contract-protect-policy-wording</p>
<p><strong>Capital model</strong></p>
<p>Capital is sourced from capital mining, with return of Nsure tokens for the miners to ensure a continuous capital support to the underwriting. Minimum Capital Requirement (MCR) is calculated based on the volume of each project and the correlation between them. A low MCR% below a pre-determined threshold will result into a lock of assets in capital pool, so as to protect the solvency the business.</p>
<p><strong>Pricing model</strong></p>
<p>Nsure uses a Dynamic Pricing Model to set the price. In this model capital supply and demand from the entire platform determines the price jointly similar to the pricing mechanism in the free market, by having Nsure tokens backing the policies bought. The price is self-adjustable to the movement of supply and demand, subject to the model, moderately stabilising the price change.</p>
<p><strong>Rating System</strong></p>
<p>Nsure uses its N-SCOSS rating system to quantify the code security of projects by assessing:</p>
<ol type="1">
<li>History and Team</li>
<li>Exposure</li>
<li>Audit</li>
<li>Code quality</li>
<li>Developer community</li>
</ol>
<p><strong>Claim process</strong></p>
<p><img src="https://3327.io/documents/research/posts/https:/399601259-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2Fnsure-network%2F-MX6EZjd-IYguhPxsT3i%2F-MX6K9inCZbKlXukrmEm%2F0.png?generation=1617178176984217&amp;alt=media" style="height: 500px; width:700px;"></p>
<p><em>Figure 4: Nsure claim process</em></p>
<p>For each policy sold there is one chance of claim filling for free. If the first claim was rejected a claim assesment fee of 10% is requested before new assesment.</p>
<p>Policy holder must provide evidence of loss on the designated project within the insurance period. Proof of loss must include:</p>
<ol type="1">
<li>Proof of ownership of affected account - After identifying his affected account, policyholder may prove his ownership over the account by signature or making a 0 amount payment to a specified address.</li>
<li>Evidence of loss - Policy holder should provide:
<ol type="1">
<li>the snapshot of the affected address’s balance at blocks before and after attack (to assist claim assessors quickly quantify the amount of lost</li>
<li>transaction of selling the damaged assets (loss is only recognised when it is realised)</li>
<li>description of the attack from project team or security specialist</li>
</ol></li>
</ol>
<p><strong>Claim assesment</strong></p>
<p>Nsure introduced a similar voting mechanism as previously mentioned protocols. Its features are:</p>
<ol type="1">
<li>To be registered as a claim assessor candidate, user must deposit a considerable amount of Nsure token. At launch, the deposit is set at () Nsure token.</li>
<li>Claim assessors are randomly picked from registered candidate. For each claim, there will be 5 claim assessors.</li>
<li>As claim assessors’ reward is proportion to premium, users tend to register for larger size policy. To get each policy equal and fair tender, users do not know the premium of the policy at registration.</li>
<li>The token will be slashed if the claim assessor’s judgment is different from the majority.</li>
</ol>
<p>After claims assessors make a decision, policyholder and other Nsure token holders can challenge this decision. This will lead to a public vote for the final conclusion on the issue.</p>
</section>
<section id="etherisc" class="level3">
<h3 class="anchored" data-anchor-id="etherisc">Etherisc</h3>
<p>So far we have been covering only protocols that offer smart contracts protection. Etherisc tries to include material goods into the story. Etherisc is a protocol to collectively build insurance products. Common infrastructure, product templates and insurance license-as-a-service make a platform that allows anyone to create their own insurance products. The first product Etherisc offered was FlightDelay Insurance. Products currently licensed are: Crop Insurance and FlightDelay Insurance. Products currently in design: Hurricane Protection, Crypto Wallet Insurance, Collateral Protection for Crypto backed Loans, Social Insurance (death, heavy illness). They are also open for product requests. Users have the option to build their own insurance product, but more information about the user needs to be provided.<sup>9</sup></p>
<p>They also launched a Joint Grant Program with Chainlink to accelerate the adoption of data-driven decentralized insurance products, so we think that special attention should be paid towards potential building with Etherisc.<sup>10</sup></p>
<p><strong>Etherisc Token</strong></p>
<p>DIP Tokens act as the native internal currency that is inseparable from the protocol and network of its users. DIP tokens are needed to earn transaction fees (% of insurance premiums or fixed cost), incentivize and reward platform users to bring risk to the network, build and maintain risk transfer products. The total supply of Etherisc Tokens is 1 Billion.</p>
<p>DIP tokens give users access to the Decentralized Insurance Platform. By staking DIP token, participants provide collateral (bond) to guarantee future performance, availability, and service levels. Staking also signals quality and reputation. As a result, participants can earn money monetizing their skills, software (for example risk models or UI/UX), risk capital, insurance licenses, claim processing, or regulatory compliance/reporting services.</p>
<p><strong>FlightDelay Insurance example from the Whitepaper - Launched on January 20 2022</strong></p>
<p>In their whitepaper’s FlightDelay Insurance product they use oraclize to obtain data from their data provider. Oraclize charges Etherisc for calling their contract. Etherisc incentivize Oraclize to provide their service correctly by :</p>
<ol type="1">
<li>In the buyers market (market with many oracles) - Demanding of Oraclize to put some tokens in a staking contract which will then returns tokens if they deliver in time and forward the tokens to Etherisc in case they miss their obligations.</li>
<li>In the sellers market (market with only one or few oracles) - Oraclize will earn an additional profit, again by staking tokens in a “staking contract”, but with reversed roles: Etherisc will stake tokens, and Oraclize will earn these tokens if they deliver, and in case they don’t deliver, the tokens are returned to Etherisc.</li>
<li>Both options can be combined with both parties staking tokens from historical flight delay</li>
</ol>
<p>Their experience with the Flight Delay DApp confirmed that insurance applications need plenty of capital to be able to scale. But that entry barrier can be overcome with cryptographic tokens that enable highly customized economics. Their goal is to allow the tokenization of risks on the platform and to make them available on a global open-access marketplace.</p>
<p>In this kind of insurance the probability is calculated from historical flight data. They used flight delay initially as a POC because of low premiums assosciated with them and under normal circumstances flight dellays are well-aproximated by independent probability events. Etherisk leverages ChainLink data.</p>
<p>On January 20th 2022 Etherisc launched FlightDelay on Gnosis Chain Mainnet. It uses Chainlink Data Feeds to autonomously issue policies and execute payouts for travelers who experience flight delays or cancellations. The result of this is insurance policies that are quicker to settle, cheaper to provision thanks to decreases in human and technical overhead and more transparent given the blockchain backend.</p>
<p>FlightDelay is now available for passenger flights globally. The insurance policies are purchasable with USDC using the Gnosis Chain on Etherisc’s FlightDelay portal. More payment options are in the works.</p>
<p><strong>Participants in the Etherisc Protocol</strong></p>
<p>Participants in the protocol are:</p>
<ol type="1">
<li>Customers - Customers can buy insurance using the token. For convenience, third parties can offer payment gateways and integrations which remove the necessity to own cryptocurrency from the end customer. Furthermore, participants can choose to offer insurance products in any native currency - be it a cryptocurrency, a token or a fiat currency. <strong>Use of token: Universal currency to buy insurance products.</strong></li>
<li>Risk model Providers and Actuaries - “Risk models are fundamental for any insurance product. The correctness of the model is precondition for the economic success of the product.Generally, because of the magnitude of value affected by errors and deviations in the model, a Risk Model Provider won’t take responsibility for the economic outcome of his model, but rather for his adherence to principles and established guidelines in his trade.” <strong>Use of token: Staking/Reward for providing or updating risk models</strong></li>
<li>Data providers and oracles - Currently, data is collected together with the application for an insurance, and the insurance company “owns” the data - even after the insurance contract is no longer valid. In a blockchain decentralized environment, the collection of data could be separated. Customers could get paid for voluntarily offering their data to a data pool, which in turn can sell this to interested parties, leaving the ownership of the data completely with the customer. This is an interesting take on handling events in the real world and the real world application of crypto insurance. <strong>Use of token: Reward for giving data. Reward for giving access to data pools. Staking / Reward for providing reliable oracles.</strong></li>
<li>Sales Agents - Sales agents are responsible for offering insurance products like in the traditional insurance. <strong>Use of token: Reward for distribution of products.</strong></li>
<li>Claim Agents - There are still many cases where automatic detection and processing the claims is not possible. Specialized and sometimes independent claims agents already exist that can be somewhat utilized e.g.&nbsp;in the area of car insurance, where they help insurers to process claims in shorter time. These claims agents can immediately use a decentralized platform, as soon as adequate products are available. <strong>Use of token: Reward for the provided service.</strong></li>
<li>License providers - Insurance in most countries depends on a proper license which can be difficult and costly to obtain. There is also a model where a license provider can act as an intermediary to regulators which is interesting if we are to build a new kind of insurance product. <strong>Use of tokens: Staking tokens to provide capital for a license provider, paying fees for licenses.</strong></li>
<li>Product managers - <strong>Use of token: Reward for service.</strong></li>
</ol>
<p>Etheriscs’ approach to crypto insurance is interesting but majority of their products are still in the works.Their first product FlightDelay Insurance was launched on January 10th 2022.<sup>11</sup></p>
</section>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Above we covered 5 of the main players of the DeFi insurance market in order to determine the products offered,the way the claims are handled and the possibility of creating new insurance protocols.</p>
<p>Quick recap:</p>
<table class="table">
<colgroup>
<col style="width: 8%">
<col style="width: 18%">
<col style="width: 15%">
<col style="width: 19%">
<col style="width: 16%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;"><strong>Nexus Mutual</strong></th>
<th style="text-align: center;"><strong>Bridge Mutual</strong></th>
<th style="text-align: center;"><strong>InsurAce</strong></th>
<th style="text-align: center;"><strong>Nsure</strong></th>
<th style="text-align: center;"><strong>Etherisc</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Mechanism</td>
<td style="text-align: center;">Mutual</td>
<td style="text-align: center;">Mutual</td>
<td style="text-align: center;">Mutual</td>
<td style="text-align: center;">Open insurance platform</td>
<td style="text-align: center;">Platform to build insurance products</td>
</tr>
<tr class="even">
<td>Insurance</td>
<td style="text-align: center;">Protocol failure, hacks</td>
<td style="text-align: center;">Smart Contracts, Stablecoins</td>
<td style="text-align: center;">Protocols, 3 CEX, 1 IDO</td>
<td style="text-align: center;">Smart Contracts</td>
<td style="text-align: center;">Material Goods, Other real-world events</td>
</tr>
<tr class="odd">
<td>Governance</td>
<td style="text-align: center;">DAO</td>
<td style="text-align: center;">DAO</td>
<td style="text-align: center;">Working on DAO governance mechanism</td>
<td style="text-align: center;">DAO</td>
<td style="text-align: center;">No data/working on DAO</td>
</tr>
<tr class="even">
<td>Identity Check</td>
<td style="text-align: center;">KYC</td>
<td style="text-align: center;">NO</td>
<td style="text-align: center;">NO</td>
<td style="text-align: center;">NO</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td>Availability</td>
<td style="text-align: center;">17 Countries are prohibited</td>
<td style="text-align: center;">Anyone</td>
<td style="text-align: center;">Anyone</td>
<td style="text-align: center;">Anyone</td>
<td style="text-align: center;">Anyone</td>
</tr>
<tr class="even">
<td>Transparency</td>
<td style="text-align: center;">Fully Transparent</td>
<td style="text-align: center;">Fully Transparent</td>
<td style="text-align: center;">Fully Transparent</td>
<td style="text-align: center;">Fully Transparent</td>
<td style="text-align: center;">Fully Transparent</td>
</tr>
<tr class="odd">
<td>Claim Assesment</td>
<td style="text-align: center;">Claim Assessors and Advisory Board</td>
<td style="text-align: center;">Voting of vBMI holders</td>
<td style="text-align: center;">Community Voting</td>
<td style="text-align: center;">Claim Assessors or Public vote</td>
<td style="text-align: center;">Oracles</td>
</tr>
</tbody>
</table>
<p>We went into detail on those protocols and have come to these conclusions:</p>
<ol type="1">
<li>In creating these kind of products there needs to be significant effort both in developing and inital investment. Protocols covered utilize Advisory Boards of insurance experts in order to create their products.</li>
<li>State regulation is a big factor in insurance in order to protect the policyholders from malicious insurance offerers. This can be a problem, depending on the states’ attitude towards cryptocurrency.</li>
<li>Handling claims is often left to the community incentivizing just behavior by staking.</li>
<li>Collecting adequate capital initially is also one of the major problems.</li>
<li>Protocols with less staked pools have higher premiums in most cases which shows us that the risk assessment is usually hard to do with new protocols.</li>
<li>There is a limited cover capacity.</li>
<li>Usually there is no cross-chain coverage which limits the protection capability of DeFi protocols on other chains.</li>
<li>Lack of protection diversity: most products offered are limited when compared to the broad coverage of risk types in the traditional insurance market.</li>
<li>Insuring real world Events is almost non-existent. Etherisc offers 2 products using Oracles but our assumption is that there is still no market need for this kind of products thus there is not much movement in this direction. However utilizing Oracles in traditional products is an interesting thing and we think should be looked more into.</li>
</ol>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs">

</div></section><section class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p><strong>HistoryLloydFounding1928?</strong>↩︎</p></li>
<li id="fn2"><p><strong>outrevilleInsuranceConcepts1998?</strong>↩︎</p></li>
<li id="fn3"><p><strong>litanRegulatingInsuranceCrisis2009?</strong>↩︎</p></li>
<li id="fn4"><p><strong>TopDecentralizedInsurance2021?</strong>↩︎</p></li>
<li id="fn5"><p><strong>NexusMutualBuy?</strong>↩︎</p></li>
<li id="fn6"><p><strong>CoverProducts?</strong>↩︎</p></li>
<li id="fn7"><p><strong>CapacityLimits?</strong>↩︎</p></li>
<li id="fn8"><p><strong>Whitepaper?</strong>↩︎</p></li>
<li id="fn9"><p><strong>EtheriscDecentralizedInsurance?</strong>↩︎</p></li>
<li id="fn10"><p><strong>etheriscEtheriscChainlinkLaunch2022?</strong>↩︎</p></li>
<li id="fn11"><p><strong>EtheriscLaunchesFlight?</strong>↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-91.gfm.html</guid>
  <pubDate>Tue, 08 Mar 2022 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Transaction splitting</title>
  <dc:creator>Andrej Rakic</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-105.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level1">
<h1>Executive Summary</h1>
<p>Many companies sell goods with a business model based on donating some percent of their profit to charity. The problem is that some of these companies don’t transparently perform these donations. If, for example, the handmade wristwatch company claims that it donates 90 percent of earnings to the charity, the buyers can’t be sure whether they indeed donated the funds to charity or just bought a very expensive product. They can only believe the company itself. Blockchain technology eliminates the need for trust.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This paper tends to explain and show how the need for trust can be eliminated when it comes to donations and setting up business models in general. Idea is to have a platform that will allow you to set up a use case in which you want to allow users to buy a product from you where a specific percentage of the purchase will go to a different wallet(s).</p>
<ul>
<li>X% of purchase transparently goes to verified charity wallet</li>
<li>a split transaction between different co-creators or marketplace and author</li>
</ul>
<p>We can develop a fully transparent set of smart contracts and protocols on some general-purpose blockchain and introduce to sellers and customers a brand new way for selling goods and doing business in general.</p>
<p>Additionally, if there are too many different wallet recipients, the splitting can be done through merkle tree claim model.</p>
</section>
<section id="goals-methodology" class="level1">
<h1>Goals &amp; Methodology</h1>
<section id="goals" class="level3">
<h3 class="anchored" data-anchor-id="goals">Goals</h3>
<ul>
<li>How to make charity donations and spending transparent</li>
<li>Eliminate the need for trusting the brand, and provide customers a way to easily verify their spendings</li>
<li>Split input transaction to several different wallets by desired percentage</li>
</ul>
</section>
<section id="methodology" class="level3">
<h3 class="anchored" data-anchor-id="methodology">Methodology</h3>
<ul>
<li>Write a set of smart contracts in Solidity for this purpose.
<ul>
<li>Pros:
<ul>
<li>Portable to any EVM general purpose blockchain</li>
<li>Native support for cryptocurrencies</li>
<li>Possibility for including ERC-20 tokens, as well</li>
<li>Tooling (Hardhat, OpenZeppelin, etc.)</li>
</ul></li>
<li>Cons:
<ul>
<li>Lack of native percentage operator in Solidity, one need to decide up to which decimal the result is reliable</li>
<li>Transaction costs</li>
</ul></li>
</ul></li>
<li>Integrate it with <a href="https://www.npmjs.com/package/bizzswap">Bizzswap</a>
<ul>
<li>Pros:
<ul>
<li>Out of the box solution for paying/swapping coins and tokens</li>
</ul></li>
<li>Cons:
<ul>
<li>Third-party dependency</li>
</ul></li>
</ul></li>
<li>Testing
<ul>
<li>Unit tests</li>
<li>Integration tests</li>
<li>End to end tests</li>
<li>Static analasys</li>
<li>Code coverage</li>
<li>Gas usage</li>
<li>Fuzz testing (optional)</li>
<li>Formal verification (optional)</li>
<li>Audit</li>
<li>Deployment to testnet</li>
</ul></li>
</ul>
<p>The beauty of the end result is that anyone can port a frontend app to this decentralized protocol and incorporate it in their business models, already existing platforms, etc.</p>
</section>
</section>
<section id="results-discussion" class="level1">
<h1>Results &amp; Discussion</h1>
<p>Transaction can be split among several parties in Solidity like this:</p>
<section id="step-1" class="level3">
<h3 class="anchored" data-anchor-id="step-1">Step 1)</h3>
<p>Smart contract should have the ability to receive native coin or any other token. There is a need for a <code>receive()</code> or <code>fallback()</code> function, depends on the implementation of the smart contract.</p>
<p><code>receive()</code> is called if <code>msg.data</code> is empty, otherwise <code>fallback()</code> is called.</p>
<pre class="solidity"><code>    /**
    Which function is called, fallback() or receive()?

           send Ether
               |
         msg.data is empty?
              / \
            yes  no
            /     \
receive() exists?  fallback()
         /   \
        yes   no
        /      \
    receive()   fallback()
    */

    // Function to receive Ether. msg.data must be empty
    receive() external payable {}

    // Fallback function is called when msg.data is not empty
    fallback() external payable {}</code></pre>
</section>
<section id="step-2" class="level3">
<h3 class="anchored" data-anchor-id="step-2">Step 2)</h3>
<p>Smart contract then needs to split the received amount among other wallets by defined percentage. Sending funds is trivial and we won’t focus on that. The most challenging part is proper ratio calculations in a language with no native support for decimal arithmetics.</p>
<p>In Solidity, one must assume that all numbers have 18 decimal precision. For example:</p>
<ul>
<li>1 is 1000000000000000000,</li>
<li>0.5 is 500000000000000000, and</li>
<li>100 is 100000000000000000000</li>
</ul>
<p>Since there are no native language support for percentage arithmetics in Solidity, devs are using Basis Points as a unit of measurement equal to 1/100th of 1 percent. This metric is commonly used for loans and bonds to signify percentage changes or yield spreads in financial instruments, especially when the difference in material interest rates is less than one percent.</p>
<ul>
<li>0.01% = 1 BPS</li>
<li>0.05% = 5 BPS</li>
<li>0.1% = 10 BPS</li>
<li>0.5% = 50 BPS</li>
<li>1% = 100 BPS</li>
<li>10% = 1 000 BPS</li>
<li>100% = 10 000 BPS</li>
</ul>
<p>Possible implementation:</p>
<pre class="solidity"><code>    function calculateFee(uint256 _amount) public pure returns(uint256) {
        // for example 1.85% is fee

        return _amount * 185 / 10000;
    }</code></pre>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>There are no blockers for implementing this idea in Solidity. The tooling is stable, the math is not complex and can be handled by the language, and the blockchain technology itself is capable for storing this type of applications.</p>


</section>
 ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-105.gfm.html</guid>
  <pubDate>Mon, 07 Mar 2022 23:00:00 GMT</pubDate>
</item>
<item>
  <title>BLS vs Schnorr vs ECDSA digital signatures</title>
  <dc:creator>Andrej Rakic</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-39.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level1">
<h1>Executive Summary</h1>
<p>Bitcoin and Ethereum both use elliptic-curve cryptography for generating keys and signing transactions. The algorithm they both use is called Elliptic Curve Digital Signature Algorithm (ECDSA), which represents a secure way of signing a message (a transaction for example) using Elliptic Curve Cryptography (ECC). This is a comparative analysis of BLS, Schnorr, and ECDSA signatures. The goal is to understand why are Ethereum and Bitcoin migrating from ECDSA, why BLS and Schnorr are superior to ECDSA and what are the key differences between them, how to use these signatures in the development and which Elliptic curves they are using and why.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>The main goal of this paper is to provide a clear understanding of the differences between them and how to use them in future protocol development; to understand why is Bitcoin migrating from ECDSA to Schnorr and why Ethereum is migrating from ECDSA to BLS.</p>
<section id="quick-recap-ecdsa" class="level2">
<h2 class="anchored" data-anchor-id="quick-recap-ecdsa">Quick recap: ECDSA</h2>
<p>Modern cryptography is founded on the idea that the key that you use to encrypt your data can be made public while the key that is used to to decrypt your data can be kept private. As such, these systems are known as public-key cryptographic systems.</p>
<p>ECDSA stands for Elliptic Curve Digital Signature Algorithm. Elliptic curve cryptography is a form of public key cryptography which is based on the algebraic structure of elliptic curves over finite fields. Used by both Bitcoin and Ethereum.</p>
<p>Elliptic curve: secp256k1</p>
<section id="secp256k1" class="level3">
<h3 class="anchored" data-anchor-id="secp256k1">secp256k1</h3>
<p>The elliptic curve domain parameters over <code>Fp</code> associated with a Koblitz curve secp256k1 are specified by the sextuple <code>T = (p, a, b, G, n, h)</code> where the finite field <code>Fp</code> is defined by:</p>
<ul>
<li>p = <code>0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F</code> = <code>2^256 − 2^32 − 2^9 − 2^8 − 2^7 − 2^6 − 2^4 − 1</code></li>
</ul>
<p>The curve <strong>E</strong>: <code>y^2 = x^3 + ax + b</code> over Fp is defined by:</p>
<ul>
<li>a = <code>0x00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</code></li>
<li>b = <code>0x00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007</code></li>
</ul>
<p>The base point <strong>G</strong> in compressed form is:</p>
<ul>
<li><code>0x02 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798</code></li>
</ul>
<p>and in uncompressed form is:</p>
<ul>
<li><code>0x04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8</code></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/posts/https:/github.com/ethereumbook/ethereumbook/raw/develop/images/simple_elliptic_curve.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
</section>
<section id="private-and-public-keys" class="level3">
<h3 class="anchored" data-anchor-id="private-and-public-keys">Private and public keys</h3>
<p>Private keys are generated as random 256 bits or 64 random hex characters or 32 random bytes. The public key is derived from the private key using ECDSA. Public key is a point on secp256k1 elliptic curve, generated by formula <code>K = k * G</code> where <code>K</code> is public key, <code>k</code> is private key, <code>G</code> is the constant point on secp256k1 elliptic curve and <code>*</code> is the multiplication operator on secp256k1 elliptic curve. There is no inverse, “<code>/</code>” operator, therefore the relationship between <code>k</code> and <code>K</code> is fixed, but can only be calculated in one direction, from <code>k</code> to <code>K</code>. A private key can be converted into a public key, but a public key cannot be converted back into a private key, because the math only works one way. The multiplication of <code>k * G</code> is equivalent to repeated addition, so <code>G + G + G + …​ + G</code>, repeated <code>k</code> times.</p>
</section>
<section id="signing-and-verification" class="level3">
<h3 class="anchored" data-anchor-id="signing-and-verification">Signing and verification</h3>
<p>To sign and verify ECDSA signature using OpenSSL, do next</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><span class="co" style="color: #5E5E5E;"># Generate private key</span></span>
<span id="cb1-2"><span class="ex" style="color: null;">openssl</span> genpkey <span class="at" style="color: #677623;">-algorithm</span> rsa <span class="at" style="color: #677623;">-out</span> privatni.pem</span>
<span id="cb1-3"></span>
<span id="cb1-4"><span class="co" style="color: #5E5E5E;"># Generate public key out of private key</span></span>
<span id="cb1-5"><span class="ex" style="color: null;">openssl</span> rsa <span class="at" style="color: #677623;">-pubout</span> <span class="at" style="color: #677623;">-in</span> privatni.pem <span class="at" style="color: #677623;">-out</span> javni.pem</span>
<span id="cb1-6"></span>
<span id="cb1-7"><span class="co" style="color: #5E5E5E;"># Test message for signing</span></span>
<span id="cb1-8"><span class="bu" style="color: null;">echo</span> <span class="st" style="color: #20794D;">"Test"</span> <span class="op" style="color: #5E5E5E;">&gt;</span> message.txt</span>
<span id="cb1-9"></span>
<span id="cb1-10"><span class="co" style="color: #5E5E5E;"># Sign the message (with Bitcoin's hashing alghorithm)</span></span>
<span id="cb1-11"><span class="ex" style="color: null;">openssl</span> dgst <span class="at" style="color: #677623;">-sha256</span> <span class="at" style="color: #677623;">-sign</span> privatni.pem <span class="at" style="color: #677623;">-out</span> signature.bin message.txt</span>
<span id="cb1-12"></span>
<span id="cb1-13"><span class="co" style="color: #5E5E5E;"># Verification</span></span>
<span id="cb1-14"><span class="ex" style="color: null;">openssl</span> dgst <span class="at" style="color: #677623;">-sha256</span> <span class="at" style="color: #677623;">-verify</span> javni.pem <span class="at" style="color: #677623;">-signature</span> signature.bin message.txt</span></code></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/posts/https:/miro.medium.com/max/1400/1*aWEbhqQIpHXZgvNpRSi54g@2x.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
</section>
<section id="ecdsa-verification-in-solidity" class="level3">
<h3 class="anchored" data-anchor-id="ecdsa-verification-in-solidity">ECDSA verification in Solidity</h3>
<pre class="solidty"><code>import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract Example {
  address public admin;

  constructor() {
    admin = msg.sender;
  }

  function verify(bytes32 _digest, bytes calldata _signature) public view returns(bool) {
    return admin == ECDSA.recover(_digest, _signature);
  }
}</code></pre>
</section>
<section id="ecdsa-verification-in-javascripttypescript" class="level3">
<h3 class="anchored" data-anchor-id="ecdsa-verification-in-javascripttypescript">ECDSA verification in Javascript/Typescript</h3>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb3-1"><span class="im" style="color: null;">import</span> { SignerWithAddress } <span class="im" style="color: null;">from</span> <span class="st" style="color: #20794D;">'@nomiclabs/hardhat-ethers/signers'</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-2"><span class="im" style="color: null;">import</span> { utils } <span class="im" style="color: null;">from</span> <span class="st" style="color: #20794D;">'ethers'</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-3"><span class="im" style="color: null;">import</span> { expect } <span class="im" style="color: null;">from</span> <span class="st" style="color: #20794D;">'chai'</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-4"></span>
<span id="cb3-5">(<span class="kw" style="color: #00769E;">async</span> () <span class="kw" style="color: #00769E;">=&gt;</span> {</span>
<span id="cb3-6">    <span class="kw" style="color: #00769E;">let</span> admin<span class="op" style="color: #5E5E5E;">:</span> SignerWithAddress<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-7"></span>
<span id="cb3-8">    [admin] <span class="op" style="color: #5E5E5E;">=</span> <span class="cf" style="color: #00769E;">await</span> ethers<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">getSigners</span>()<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-9"></span>
<span id="cb3-10">    <span class="kw" style="color: #00769E;">const</span> message<span class="op" style="color: #5E5E5E;">:</span> <span class="dt" style="color: #AD0000;">string</span> <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">'Hello World'</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-11">    <span class="kw" style="color: #00769E;">const</span> msgHash<span class="op" style="color: #5E5E5E;">:</span> <span class="dt" style="color: #AD0000;">string</span> <span class="op" style="color: #5E5E5E;">=</span> utils<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">hashMessage</span>(message)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-12">    <span class="kw" style="color: #00769E;">const</span> digest<span class="op" style="color: #5E5E5E;">:</span> <span class="bu" style="color: null;">Uint8Array</span> <span class="op" style="color: #5E5E5E;">=</span> utils<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">arrayify</span>(msgHash)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-13"></span>
<span id="cb3-14">    <span class="kw" style="color: #00769E;">const</span> signature<span class="op" style="color: #5E5E5E;">:</span> <span class="dt" style="color: #AD0000;">string</span> <span class="op" style="color: #5E5E5E;">=</span> <span class="cf" style="color: #00769E;">await</span> admin<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">signMessage</span>(message)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-15"></span>
<span id="cb3-16">    <span class="kw" style="color: #00769E;">const</span> address<span class="op" style="color: #5E5E5E;">:</span> <span class="dt" style="color: #AD0000;">string</span> <span class="op" style="color: #5E5E5E;">=</span> utils<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">recoverAddress</span>(digest<span class="op" style="color: #5E5E5E;">,</span> signature)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-17">    <span class="fu" style="color: #4758AB;">expect</span>(address)<span class="op" style="color: #5E5E5E;">.</span><span class="at" style="color: #677623;">to</span><span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">equal</span>(admin<span class="op" style="color: #5E5E5E;">.</span><span class="at" style="color: #677623;">address</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-18">})()<span class="op" style="color: #5E5E5E;">;</span></span></code></pre></div>
</section>
</section>
</section>
<section id="goals-methodology" class="level1">
<h1>Goals &amp; Methodology</h1>
<section id="bls" class="level2">
<h2 class="anchored" data-anchor-id="bls">BLS</h2>
<p>BLS stands for Boneh-Lynn-Shacham, it’s a signature scheme that is based on bi-linear pairings. A pairing, defined as <code>e(,)</code>, is a bilinear map of 2 groups <code>G1</code> and <code>G2</code> in some other group, <code>GT</code>. <code>e(,)</code> takes as arguments points in G1 and G2.</p>
<p>Pairings that verifies a signature looks like this:</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><span class="ex" style="color: null;">e</span><span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">g1,</span> sig<span class="kw" style="color: #00769E;">)</span> <span class="ex" style="color: null;">=</span> e<span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">P,</span> H<span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">m</span><span class="kw" style="color: #00769E;">))</span></span>
<span id="cb4-2"></span>
<span id="cb4-3"><span class="co" style="color: #5E5E5E;"># or in expanded form like this</span></span>
<span id="cb4-4"><span class="ex" style="color: null;">e</span><span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">g1,</span> pk<span class="pp" style="color: #AD0000;">*</span>H<span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">m</span><span class="kw" style="color: #00769E;">))</span> <span class="ex" style="color: null;">=</span> e<span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">pk*g1,</span> H<span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">m</span><span class="kw" style="color: #00769E;">))</span> <span class="ex" style="color: null;">=</span> e<span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">g1,</span> pk<span class="pp" style="color: #AD0000;">*</span>H<span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">m</span><span class="kw" style="color: #00769E;">))</span></span></code></pre></div>
<p><code>H(m)</code> is hashing a message to a point on an elliptic curve.</p>
<p>BLS consists of:</p>
<ul>
<li><p><strong>KeyGen</strong> — choose a random <code>α</code>. Given generator <code>g1</code>, <code>P=α*g1</code></p></li>
<li><p><strong>Sign</strong> — <code>σ = α*H(m) ∈ G2</code> (in the case of ETH 2.0)</p></li>
<li><p><strong>Verify<code>(P,m, σ)</code></strong> — if <code>e(g1, σ) = e(P, H(m))</code> return <code>true</code>.</p></li>
</ul>
<p>Elliptic curve: BLS12-381</p>
<section id="bls12-381" class="level3">
<h3 class="anchored" data-anchor-id="bls12-381">BLS12-381</h3>
<p>BLS12-381 is a pairing-friendly elliptic curve construction that is optimal for zk-SNARKs at the 128-bit security level.</p>
<p>Barreto-Naehrig (BN) curves are a class of pairing-friendly elliptic curve constructions built over a base field <code>Fp</code> of order <code>r</code>, where <code>r≈p</code>. It is possible to construct a new BN curve that targets 128-bit security by selecting a curve closer to <code>p≈2^(384)</code>. However, the larger group order <code>r</code> impairs the performance of multi-exponentiation, fast fourier transforms and other cryptographic operations.</p>
<p>Barreto-Lynn-Scott (BLS) curves are a slightly older class of pairing-friendly curves which now appear to be more useful for targeting this security level. Current research suggests that with <code>p≈2^(384)</code>, and with an embedding degree of 12, these curves target the 128-bit security level.</p>
</section>
<section id="private-and-public-keys-1" class="level3">
<h3 class="anchored" data-anchor-id="private-and-public-keys-1">Private and public keys</h3>
<p>The private/secret key (to be used for signing) is just a randomly chosen number between <code>1</code> and <code>r−1</code> inclusive. We’ll call it <code>pk</code>.</p>
<p>The corresponding public key is <code>P=[pk]g1</code>, where <code>g1</code> is the chosen generator of <code>G1</code>. That is, <code>g1</code> multiplied by <code>pk</code>, which is <code>g1</code> added to itself <code>pk</code> times.</p>
<p>The discrete logarithm problem means that it is unfeasible to recover <code>pk</code> given the public key <code>P</code>.</p>
</section>
<section id="signing" class="level3">
<h3 class="anchored" data-anchor-id="signing">Signing</h3>
<p>One can sign the message by calculating the signature <code>σ=[pk]H(m)</code>. That is, by multiplying the hash point by our secret key. But what is <code>H</code>?</p>
<p>To calculate a digital signature over a message, we first need to transform an arbitrary message (byte string) to a point on the <code>G2</code> curve. The initial implementation in Eth2 was “hash-and-check”:</p>
<ol type="1">
<li>Hash your message to an integer modulo <code>q</code></li>
<li>Check if there is a point on the curve with this <code>x</code>-coordinate. If not, add one and repeat</li>
<li>Once you have a point on the curve multiply it by the <code>G2</code> cofactor to convert it into a point in <code>G2</code>.</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/posts/https:/miro.medium.com/max/1400/1*IpmIdJLR36iHnOHq1OqHnw@2x.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
</section>
<section id="verification" class="level3">
<h3 class="anchored" data-anchor-id="verification">Verification</h3>
<p>Given a message <code>m</code>, a signature <code>σ</code>, and a public key <code>P</code>, we want to verify that it was signed with the <code>pk</code> corresponding to <code>P</code>. The signature is valid if, and only if, <code>e(g1,σ)=e(P,H(m))</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/posts/https:/miro.medium.com/max/1400/1*CyqBtsUTnME5R4QTU_ZZCg@2x.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
</section>
<section id="aggregation" class="level3">
<h3 class="anchored" data-anchor-id="aggregation">Aggregation</h3>
<p>A really neat property of BLS signatures is that they can be aggregated, so that we need only two pairings to verify a single message signed by <code>n</code> parties, or <code>n - 1</code> pairings to verify <code>n</code> different messages signed by <code>n</code> parties, rather than <code>2n</code> pairings you might naively expect to need. Pairings are expensive to compute, so this is very attractive.</p>
<p>To aggregate signatures we just have to add up the <code>G2</code> points they correspond to: <code>σagg=σ1+σ2+...+σn</code>. We also aggregate the corresponding <code>G1</code> public key points <code>Pagg=P1+P2+...+Pn</code>.</p>
<p>Now the magic of pairings means that we can just verify that <code>e(g1,σagg)=e(Pagg,H(m))</code> to verify all the signatures together with just two pairings.</p>
</section>
<section id="bls-verification-in-solidity" class="level3">
<h3 class="anchored" data-anchor-id="bls-verification-in-solidity">BLS verification in Solidity</h3>
<p>Below shows an example Solidity function that verifies a single signature. EIP-197 defined a pairing precompile contract at address <code>0x8</code> and requires input to a multiple of <code>192</code>. This assembly code calls the precompile contract at address <code>0x8</code> with inputs.</p>
<pre class="solidity"><code>  // Negated genarator of G2
  uint256 constant nG2x1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
  uint256 constant nG2x0 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
  uint256 constant nG2y1 = 17805874995975841540914202342111839520379459829704422454583296818431106115052;
  uint256 constant nG2y0 = 13392588948715843804641432497768002650278120570034223513918757245338268106653;


function verifySingle(
    uint256[2] memory signature, \\ small signature
    uint256[4] memory pubkey, \\ big public key: 96 bytes
    uint256[2] memory message
) public view returns (bool) {
    uint256[12] memory input = [
        signature[0],
        signature[1],
        nG2x1,
        nG2x0,
        nG2y1,
        nG2y0,
        message[0],
        message[1],
        pubkey[1],
        pubkey[0],
        pubkey[3],
        pubkey[2]
    ];
    uint256[1] memory out;
    bool success;

    assembly {
        success := staticcall(sub(gas(), 2000), 8, input, 384, out, 0x20)
        switch success
            case 0 {
                invalid()
            }
    }

    require(success, "");
    return out[0] != 0;
}</code></pre>
</section>
<section id="bls-verification-in-javascripttypescript" class="level3">
<h3 class="anchored" data-anchor-id="bls-verification-in-javascripttypescript">BLS verification in Javascript/Typescript</h3>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><span class="kw" style="color: #00769E;">const</span> bls <span class="op" style="color: #5E5E5E;">=</span> <span class="pp" style="color: #AD0000;">require</span>(<span class="st" style="color: #20794D;">'@noble/bls12-381'</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-2"></span>
<span id="cb6-3">(<span class="kw" style="color: #00769E;">async</span> () <span class="kw" style="color: #00769E;">=&gt;</span> {</span>
<span id="cb6-4">    <span class="co" style="color: #5E5E5E;">// keys, messages &amp; other inputs can be Uint8Arrays or hex strings</span></span>
<span id="cb6-5">    <span class="kw" style="color: #00769E;">const</span> privateKey <span class="op" style="color: #5E5E5E;">=</span></span>
<span id="cb6-6">        <span class="st" style="color: #20794D;">'67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c'</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-7">    <span class="kw" style="color: #00769E;">const</span> message <span class="op" style="color: #5E5E5E;">=</span> <span class="st" style="color: #20794D;">'64726e3da8'</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-8">    <span class="kw" style="color: #00769E;">const</span> publicKey <span class="op" style="color: #5E5E5E;">=</span> bls<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">getPublicKey</span>(privateKey)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-9">    <span class="kw" style="color: #00769E;">const</span> signature <span class="op" style="color: #5E5E5E;">=</span> <span class="cf" style="color: #00769E;">await</span> bls<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">sign</span>(message<span class="op" style="color: #5E5E5E;">,</span> privateKey)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-10">    <span class="kw" style="color: #00769E;">const</span> isValid <span class="op" style="color: #5E5E5E;">=</span> <span class="cf" style="color: #00769E;">await</span> bls<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">verify</span>(signature<span class="op" style="color: #5E5E5E;">,</span> message<span class="op" style="color: #5E5E5E;">,</span> publicKey)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-11">    <span class="bu" style="color: null;">console</span><span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">log</span>({ publicKey<span class="op" style="color: #5E5E5E;">,</span> signature<span class="op" style="color: #5E5E5E;">,</span> isValid })<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-12"></span>
<span id="cb6-13">    <span class="co" style="color: #5E5E5E;">// Sign 1 msg with 3 keys</span></span>
<span id="cb6-14">    <span class="kw" style="color: #00769E;">const</span> privateKeys <span class="op" style="color: #5E5E5E;">=</span> [</span>
<span id="cb6-15">        <span class="st" style="color: #20794D;">'18f020b98eb798752a50ed0563b079c125b0db5dd0b1060d1c1b47d4a193e1e4'</span><span class="op" style="color: #5E5E5E;">,</span></span>
<span id="cb6-16">        <span class="st" style="color: #20794D;">'ed69a8c50cf8c9836be3b67c7eeff416612d45ba39a5c099d48fa668bf558c9c'</span><span class="op" style="color: #5E5E5E;">,</span></span>
<span id="cb6-17">        <span class="st" style="color: #20794D;">'16ae669f3be7a2121e17d0c68c05a8f3d6bef21ec0f2315f1d7aec12484e4cf5'</span><span class="op" style="color: #5E5E5E;">,</span></span>
<span id="cb6-18">    ]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-19">    <span class="kw" style="color: #00769E;">const</span> messages <span class="op" style="color: #5E5E5E;">=</span> [<span class="st" style="color: #20794D;">'d2'</span><span class="op" style="color: #5E5E5E;">,</span> <span class="st" style="color: #20794D;">'0d98'</span><span class="op" style="color: #5E5E5E;">,</span> <span class="st" style="color: #20794D;">'05caf3'</span>]<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-20">    <span class="kw" style="color: #00769E;">const</span> publicKeys <span class="op" style="color: #5E5E5E;">=</span> privateKeys<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">map</span>(bls<span class="op" style="color: #5E5E5E;">.</span><span class="at" style="color: #677623;">getPublicKey</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-21">    <span class="kw" style="color: #00769E;">const</span> signatures2 <span class="op" style="color: #5E5E5E;">=</span> <span class="cf" style="color: #00769E;">await</span> <span class="bu" style="color: null;">Promise</span><span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">all</span>(</span>
<span id="cb6-22">        privateKeys<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">map</span>((p) <span class="kw" style="color: #00769E;">=&gt;</span> bls<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">sign</span>(message<span class="op" style="color: #5E5E5E;">,</span> p))</span>
<span id="cb6-23">    )<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-24">    <span class="kw" style="color: #00769E;">const</span> aggPubKey2 <span class="op" style="color: #5E5E5E;">=</span> bls<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">aggregatePublicKeys</span>(publicKeys)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-25">    <span class="kw" style="color: #00769E;">const</span> aggSignature2 <span class="op" style="color: #5E5E5E;">=</span> bls<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">aggregateSignatures</span>(signatures2)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-26">    <span class="kw" style="color: #00769E;">const</span> isValid2 <span class="op" style="color: #5E5E5E;">=</span> <span class="cf" style="color: #00769E;">await</span> bls<span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">verify</span>(aggSignature2<span class="op" style="color: #5E5E5E;">,</span> message<span class="op" style="color: #5E5E5E;">,</span> aggPubKey2)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-27">    <span class="bu" style="color: null;">console</span><span class="op" style="color: #5E5E5E;">.</span><span class="fu" style="color: #4758AB;">log</span>({ signatures2<span class="op" style="color: #5E5E5E;">,</span> aggSignature2<span class="op" style="color: #5E5E5E;">,</span> isValid2 })<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb6-28">})()<span class="op" style="color: #5E5E5E;">;</span></span></code></pre></div>
</section>
</section>
<section id="schnorr" class="level2">
<h2 class="anchored" data-anchor-id="schnorr">Schnorr</h2>
<p>Schnorr signatures are generated slightly differently than ECDSA. Instead of two scalars <code>(r,s)</code> we use a point <code>R</code> and a scalar <code>s</code>. Similar to ECDSA, <code>R</code> is a random point on elliptic curve <code>(R = k×G)</code>. Second part of the signature is calculated slightly differently: <code>s = k + hash(P,R,m) ⋅ pk</code>. Here <code>pk</code> is your private key, <code>P = pk×G</code> is your public key, <code>m</code> is the message. Then one can verify this signature by checking that <code>s×G = R + hash(P,R,m)×P</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/posts/https:/miro.medium.com/max/1400/1*hIjYiOdjwBVqdRpa5lrJOg@2x.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
<p>This equation is linear, so equations can be added and subtracted with each other and still stay valid. This brings us to several nice features of Schnorr signatures that we can use.</p>
<section id="batch-validation" class="level3">
<h3 class="anchored" data-anchor-id="batch-validation">Batch validation</h3>
<p>To verify a block in Bitcoin blockchain we need to make sure that all signatures in the block are valid. If one of them is not valid we don’t care which one - we just reject the whole block and that’s it.</p>
<p>With ECDSA every signature has to be verified separately. Meaning that if we have 1000 signatures in the block we will need to compute 1000 inversions and 2000 point multiplications. In total ~3000 heavy operations.</p>
<p>With Schnorr signatures we can add up all the signature verification equations and save some computational power. In total for a block with 1000 transactions we need to verify that</p>
<pre><code>(s1+s2+…+s1000)×G=(R1+…+R1000)+(hash(P1,R1,m1)×P1+ hash(P2,R2,m2)×P2+…+hash(P1000,R1000,m1000)×P1000)</code></pre>
<p>Here we have a bunch of point additions (almost free in sense of computational power) and 1001 point multiplication. This is already a factor of 3 improvement - we need to compute roughly one heavy operation per signature.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/posts/https:/miro.medium.com/max/1400/1*ZVUPaZBVXs-ORSI_rrh0fw@2x.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
</section>
<section id="key-aggregation" class="level3">
<h3 class="anchored" data-anchor-id="key-aggregation">Key aggregation</h3>
<p>We want to keep our bitcoins safe, so we might want to use at least two different private keys to control bitcoins. One we will use on a laptop or a phone and another one - on a hardware wallet / cold wallet. So when one of them is compromised we still have control over our bitcoins.</p>
<p>Currently it is implemented via 2-of-2 multisig script. This requires two separate signatures to be included in the transaction.</p>
<p>With Schnorr signatures we can use a pair of private keys <code>(pk1,pk2)</code> and generate a shared signature corresponding to a shared public key <code>P=P1+P2=pk1×G+pk2×G</code>. To generate this signature we need to choose a random number on every device <code>(k1,k2)</code>, generate a random point <code>Ri=ki×G</code>, add them up to calculate a common <code>hash(P,R1+R2,m)</code> and then get <code>s1</code> and <code>s2</code> from every device <code>(si = ki + hash(P,R,m) ⋅ pki)</code>. Then we can add up these signatures and use a pair <code>(R, s) = (R1+R2, s1+s2)</code> as our signature for shared public key <code>P</code>. No one else won’t be able to say if it is an aggregated signature or not - it looks exactly the same as a normal Schnorr signature.</p>
</section>
</section>
</section>
<section id="results-discussion" class="level1">
<h1>Results &amp; Discussion</h1>
<p>A major reason to use this new stack is that it admits efficient aggregation of many signatures into one signature which directly contributes to the scalability of ETH2.0’s security. With this transition, ECDSA signatures aren’t enough anymore as the number of signatures to verify was too big and would take too long on the average machine.</p>
<p>ETH 2.0 definies 64 committees for every block and each committee can have as many as 2048 validators, with each epoch consisting of 32 blocks. Under normal ECDSA that means 131,072 (64*2048) signatures for every block (12 sec), and 4,194,304 for every epoch (32 blocks). This means that an epoch’s worth of signatures would be 33.6 megabytes which comes to ~7.6 gigabytes per day. In this case, all of the false claims about the ETH 1.0 state-size reaching 1TB back in 2018 would be true in ETH 2.0’s case in fewer than 133 days (based on signatures alone). If every node in the network will need to verify each signature it becomes infeasible to build a scalable, sharded, blockchain.</p>
<p>As a solution to the above, signature aggregation was considered. Technically it will mean that many signatures could be verified in a batch, significantly shortening the time and resources required. ETH 2.0 makes use of the BLS signatures - a signature scheme defined over several elliptic curves that is friendly to aggregation. On the specific curve chosen, signatures are 96 bytes each. If Alice produces signature A, and Bob’s signature is B on the same data, then both Alice’s and Bob’s signatures can be stored and checked together by only storing C = A + B. By using signature aggregation, only 1 signature needs to be stored and checked for the entire committee. This reduces the storage requirements to less than 2 megabytes per day.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>It will be interesting to see how blockchain clients will implement these new changes and how efficient will they be because we already concluded from the paper that the reason for switching from ECDSA is justified. We should monitor also the Bitcoin timeframe to be able to disscus more about Schnoor signatures implementation.</p>


</section>
 ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-39.gfm.html</guid>
  <pubDate>Thu, 03 Mar 2022 23:00:00 GMT</pubDate>
  <media:content url="https://github.com/ethereumbook/ethereumbook/raw/develop/images/simple_elliptic_curve.png" medium="image" type="image/png"/>
</item>
<item>
  <title>ROTOKEN</title>
  <dc:creator>Aleksandar Veljković</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-103.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level1">
<h1>Executive Summary</h1>
<p>Organisations may include non-founder members with specific roles (treasurer, secretary, board members…) with higher permission levels, compared to the regular members. Members that have permission levels which include control over organisation finances represent a high risk for the organisation as there is a high risk of losing money if malicious members perform illegal transfers. That problem is especially present in the world of cryptocurrency where transfers cannot be revoked, once transaction is executed there is no rollback. The use of multisig might be an obvious solution, but the high overhead cost of writting multiple signatures on blockchain, even if the transaction is valid, may not be acceptable in many situations where there is a high frequency of transactions.</p>
<p>This research proposes a solution for this problem, restricted to the world of crypto-financial transactions, by introducing a rotating token which guarantees randomised selection of members that would be granted specified roles over fixed period of time while allowing blockchain money-transferring transactions to be executed only by the members that are holding the token. For improved prevention of unwanted transactions, the transactions may be disputed before their execution, which allows higher control over money transfers and enables improved protection of organisation funds. All transactions are transparent to all approved members, which adds extra layer of transparency over the entire organisation budget.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Money transfer transactions are the essential parts of any organisation. Protection of organisation finances and prevention of malicious transactions is one of the top priorities. There is usually one, or a few people that are responsible for all money transfers in the organisation and are often the only members that are actually aware of those transfers. Malicious member with access to organisation funds may use the opportunity to leak money from the organisation for the causes that are against the organisation rules or even against the law. Board members of the organisation are ofter not aware of those malicious activities as the members that perform those transaction also prepare financial reports, hiding their tracks. An example would be a fake invoice representing payment for the fictive service that actually represents money laundering. Even invoice payments for the regular services may be modified with highly increased price.</p>
<p>Current mechanisms for controlling financial transactions in smaller organisations basically do no exist as every lost cent is easily trackable when dealing with smaller amounts of money. When dealing with large number of transactions and bigger funds, the situation is not that clear. Bigger organisations specify budgets for certain topics, restricting the maximum amount spent on specific topic, therefore defining the upper limit on transaction fraud potential [1]. Those budgets are not small, Microsoft Corporation spent more than 20 billion USD on sales and marketing in 2021 [2]. There is a big potential for hiding malicious transactions.</p>
<p>Choosing members that would be granted access to funds is currently solved in two ways: - Hiring accounting department [3]. In this setup, the employees are hired for the longer period of time, sharing the responsibility with each other and the head of the department. - Electing treasurer [4]. In this setup, the treasurer role can be assigned to different members, often by voting. The job of the treasurer is a person responsible for observing the accountant department, but in smaller organisation he is often the only person dedicated to manage and observe financial flows. The issue appears when the malicious clique tampers the voting and forces the election of a certain trusted member as long as they all benefit from it. There is also the case where the treasurer role is assigned once and never changed, assuming his honest work.</p>
<p>To prevent the problem, it is important to understand its cause. Newly granted members with access to organisation funds are often working by the book, scared of possible consequences when caught performing a malicious activity. As the time goes by, their actions are not carefully observed and their position in the organisation becomes stable. At that point, the risk of malicious transactions becomes higher as the actors are not observed and there was enough time to form a clique with other members [5,6]. To quote Margaret Murray: “Governments are like underwear. They start smelling pretty bad if you don’t change them once in a while.” The same goes with any position of power, even if that power includes just access to finances.</p>
<p>It seems that there are two main problems, unbiased change of authorisation and transparent transaction control.</p>
<p>Crypto-world introduced multisig wallets for improved safety. The problem with this approach is that it introduces costs to multiple members for executing one transaction even if that transaction is not malicious. The better approach would be a procedure that would add extra cost only to prevent malicious transactions, thus saving money when the transactions are not malicious.</p>
<p>Unbiased selection of participants to perform certain actions is demonstrated in certain Blockchains where validator nodes are selected in Round robin manner. Round robin approach may not be adequate for selecting treasurers as it is predictable and assumes that next treasurer will be available to accept the role. In general, unbiased selection should be incorporated wherever there is a high risk involved with knowing the choice in advance or where all choices should be equaly probable. Such cases include distributing role, data or duties to randomly selected entities, selection of randomly generated teams (such as jury selection) and similar.</p>
</section>
<section id="goals-methodology" class="level1">
<h1>Goals &amp; Methodology</h1>
<p>The main goal of this research was to find a solution for having unbiased selection of personnel with access to finances as well as transaction control. The way to get to the solution was to present first all the requirements and restrictions.</p>
<p>The transactions that are focus of this research are blockchain transactions. This research will focus on Ethereum money-transferring transactions so the base element of the solutions would be Ethereum smart contract, for this research named ROTOKEN. ROTOKEN smart contract includes NFT token and wallet. The wallet is controlled only by the owner of the NFT.</p>
<p>All listed members of the organisation should be automatically whitelisted, meaning that all members should be able to get selected for special roles involving access to finances. This is naturally enforced as the salary payments are also transactions from organisation funds and therefore controlled by the ROTOKEN smart contract.</p>
<p>Unbiased selection can only be performed using unbiased probability distribution over the members that are applying for the position. The selection needs to take into account that next selected member can’t be the same as the previous one. Random selection on blockchain is a tricky part as it relies on values that can be predicted in advance. One of the sources of pseudo-randomness is the block hash, as it is a result of SHA3 function. However, the value is predictable by the miners and it can be tampered so it should not be used as a source of randomness. Another approach is using verifiable random functions such as Chainlink VRF. This might be costly but it is a good solution. This research also proposes another, possibly cheaper approach. Selecting the latest transaction hashes of <embed src="https://latex.codecogs.com/svg.latex?k" title="k" class="img-fluid"> wallets outside of the organisation ,with the most frequent transactions, and hashing them all together may be a good source of randomness as the main problem with predictable randomness from block hash is the ability of the miner to reorder transactions until the desired hash is achieved. By selecting transaction hashes instead of blocks, the only way to tamper with the randomness is to selectively mine transactions which leaves much less room for tampered combinations and transaction hashes are close to random as they are influenced by many changing variables.</p>
<p>Selection of new members with special roles should happen regularly in fixed intervals. As transaction of changing the role needs to be executed on blockchain, it is required that transaction is explicitly invoked. To incentivise regular changes, organisation funds would be blocked for transactions until the role is changed. Role change should not be allowed during before the end of current member’s term unless it is invoked by the current member. The role transfer to a new member is done by transferring ROTOKEN NFT.</p>
<p>Transaction that is submitted on blockchain can’t be revoked. The only way to prevent transaction execution is to prevent its submission. Proposed solution includes two step execution. The first step is transaction announcement, which should be executed on smart contract and contain details about target wallet and the amount being sent. The second step is transaction execution, which submits pending transaction to blockchain for execution. Between two steps, certain period of time should be left for disputes. If the dispute is initiated by enough participants the transaction will be canceled, where enough should be &gt;51% or &gt;2/3, but the exact limit would be configurable value.</p>
<p>To disincentivise submission of malicious transactions, that would eventually probably be disputed but also add extra cost for disputing, submitter should be penalised. For a member to loose money it is required that the member has the money in first place, so the safest way to ensure successful penalisation is to include staking. The money staked by the submitter would be lost in case of successful dispute.</p>
<p>Lost staked money needs to change ownership. If the money is sent to disputers, there would exist an incentive for members to dispute every transaction and earn money. To prevent this behaviour, the proposed solutions is transferring money to the organisation wallet. This solution may seem problematic and unnatural but there is an explanation for that. One way to look at staking is to take existing money out of the pocket. The other way is to take money “from the future”, meaning that member may have dedicated annual fond which is used to issue monthly payments as salary and may also be perceived as staked money. In this case, the penalisation would assume reduction of the future salary which technically is returning money back to the organisation. To further disincentivise disputes from the side of the organisation executives, disputed transaction, defined by the receiver’s address and the amount of money to be transferred, blocks further transfers to receiver’s address for certain amount of time. If the disputed transaction was indeed malicious, this mechanism will block further transactions to that address, preventing new attempts. If the transaction was falsely disputed and the receiver is a proper receiver of organisation’s money, by preventing the transaction and blocking the transfer to the proper receiver, the behaviour directly disrupts regular functioning of the organisation.</p>
</section>
<section id="results-discussion" class="level1">
<h1>Results &amp; Discussion</h1>
<p>ROTOKEN smart contract should follow modifier ERC-721 smart contract. Token transfer should be possible only by internal call and the token should be transferred to randomly selected whitelisted member. Additionally, the smart contract should include: - list of whitelisted members, with getters and setters - list of transactions with statuses - dispute function - transaction announcement and execution functions - ownership change function, which would internally call transfer function</p>
<p>Proposed ROTOKEN smart contract interface:</p>
<pre><code>interface ROTOKEN {
    // + ...ERC-721 interface

    Enum { PENDING, DISPUTED, CANCELED, FAILED, EXECUTED } transactionStatus
    struct (
        transactionStatus status,
        address currentTokenOwner
        address receiver,
        uint256 amount,
    ) transactionData;

    mapping(transactionId =&gt; transactionData) public transactions
    address[] whitelistedMembers;

    event TransactionStatusChanged(uint256 indexed transactionId, transactionStatus status)

    function announceTransaction(address receiver, uint256 amount) public returns(uint256 transactionId);
    function executeTransaction(uint256 transactionId) public;
    function dispute(uint256 transactionId) public;
    function changeOwnership();
}</code></pre>
<section id="potential-markets" class="level2">
<h2 class="anchored" data-anchor-id="potential-markets">Potential markets</h2>
<p>Potential markets that might be interested to use ROTOKEN include: - DAOs - Companies with frequent audits by the investors, board members or shareholders, mostly startups - Banks - Government organisations related with public government funds</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>ROTOKEN smart contract proposes solutions for unbiased selection of members for granting control over organisation funds and incentive based transaction control. Minimal additional operating costs required for essential control are added, on top of regular transaction costs. The smart contact extends ERC-721 interface with certain modifications and extensions which makes ROTOKEN NFT compatible for integration with the existing systems where the ERC-721 tokens are used. Those systems may use the information about the ownership of the ROTOKEN to grant the owners additional privileges, like document signing, voting etc. Next steps include market evaluation, PoC implementation and detailed operating cost estimation.</p>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>



</section>
<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs">
<p>[1] https://corporatefinanceinstitute.com/resources/knowledge/finance/financial-controls/</p>
<p>[2] https://www.statista.com/statistics/506534/microsoft-sales-marketing-expenditure/</p>
<p>[3] https://www.investopedia.com/terms/a/accountant.asp</p>
<p>[4] https://nonprofitlawblog.com/treasurer-duties/</p>
<p>[5] https://corporatefinanceinstitute.com/resources/knowledge/other/fraud-red-flags/</p>
<p>[6] https://www.nsu.edu/About/Administrative-Offices-Services/Internal-Audit/Making-a-Report/Red-Flags-of-Fraud.aspx</p>
</div></section></div> ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-103.gfm.html</guid>
  <pubDate>Wed, 02 Mar 2022 23:00:00 GMT</pubDate>
  <media:content url="https://latex.codecogs.com/svg.latex?k " medium="image"/>
</item>
<item>
  <title>Building on Filecoin and Filecoin Proofs</title>
  <dc:creator>Aleksandar Damjanovic</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-38.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive Summary</h2>
<p>When looking to build dApps that utilize decentralized storage Filecoin seems like the best option even with its flaws like : absent proof of deletion for the client, absent encryption, impossible modifying of the stored data and the durability problem of Filecoin’s Proof of Replication. This research gives an overview of competitors in decentralized storage solution field with a focus on Filecoin protocol. It also shows how its competitor Storj differs from Filecoin and the current grant opportunities for potential building on it. Considering the results of the research Filecoin seems to be the best option considering the popularity and the size of its ecosystem. Currently there is no interest for building on and with Filecoin and this is a purely explorative work without experiments, in order to test the researcher’s methodology and the approach to research. However, it proposes a question about a potential way of improving Filecoin, or creating both safer protocol for the user and cheaper for the storage miners.</p>
</section>
<section id="goals-methodology" class="level2">
<h2 class="anchored" data-anchor-id="goals-methodology">Goals &amp; Methodology</h2>
<p>The aim of this research is to explore Filecoin protocol and show its fallacies as much as writer is possible with a goal of inspiring building applications that utilize Filecoin, new protocols or improving Filecoin via building for it. The paper will compile the list of all fallacies and possibilities for improvement for Filecoin, opportunities for building on it, and the current state of decentralized storage market mainly comparing Storj and Filecoin.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Unlike a centralized server operated by a single company, decentralized storage systems consist of a peer-to-peer network of user-operators who hold a portion of the overall data. The platforms can store any data sent by the user, with some platforms more focusing on encryption. There is no official data disclosing the types of data stored. This research will be covering contract-based persistence platforms with a focus on Filecoin.</p>
<p>Contract-based persistence means that data cannot be replicated by every node and stored forever, and instead must be upkept with contract agreements. These are agreements made with multiple nodes that have promised to hold a piece of data for a period of time. They must be refunded or renewed whenever they run out to keep the data persisted. Platforms with contract-based persistence currently present on the market are:</p>
<ul>
<li><p>Filecoin</p></li>
<li><p>Skynet</p></li>
<li><p>Storj</p></li>
<li><p>0Chain</p></li>
</ul>
<p><strong>Filecoin</strong> is a peer-to-peer network that stores files with built in economic incentives to ensure files are stored reliably over time. Users pay to store their files on storage providers. Storage providers are computers responsible for storing files and proving they have stored the files correctly over time. Available storage and the price of it is not controlled by any company. Anyone who wants to store their files or get paid for storing other users files can join Filecoin is written in its documentation, but is that really the case? It will be further explored in later sections. Filecoin’s native currency is FIL. Storage providers earn units of FIL for storing user’s data. Its blockchain records transactions along with proofs from storage providers that they are storing files correctly.</p>
<p>Currently Filecoin stores over <strong>40.0453 PiB</strong> of users data over <strong>1,848,292</strong> deals.<sup>1</sup></p>
<p>When users want to store their files on Filecoin they use terminal or different guis that have been built by developers to choose between cost, redundancy and speed and they select the storage provider whose storage offer is best suited for their needs. Applications that implement filecoin negotiate storage with storage providers. There is no need for different API for each provider.<sup>2</sup></p>
<p>“While interacting with IPFS does not require using Filecoin, all Filecoin nodes are IPFS nodes under the hood, and (with some manual configuration) can connect to and fetch IPLD-formatted data from other IPFS nodes using libp2p. However, Filecoin nodes don’t join or participate in the public IPFS DHT. IPFS alone does not include a built-in mechanism to incentivize the storage of data for other people. This is the challenge Filecoin aims to solve. Filecoin is built on IPFS to create a distributed storage marketplace for long-term storage.”<sup>3</sup></p>
</section>
<section id="filecoins-proof-system" class="level2">
<h2 class="anchored" data-anchor-id="filecoins-proof-system">Filecoin’s Proof System</h2>
<p>Filecoin uses Proof of Replication (PoRep) and Proof of Spacetime (poSt).</p>
<p>In a Proof of Replication, a storage miner proves that they are storing a physically unique copy, or replica, of the data. Proof of Replication happens just once, at the time the data is first stored by the miner. As the storage miner receives each piece of client data they place it into a sector, fundamental unit of storage in Filecoin. Sectors can contain pieces from multiple deals and clients. Steps in PoRep:</p>
<section id="proof-of-replication" class="level3">
<h3 class="anchored" data-anchor-id="proof-of-replication">Proof of Replication</h3>
<ol type="1">
<li><strong>Filling sectors and generating the Commd</strong></li>
</ol>
<p>Once a sector is full a Commitment of Data (CommD) is created, representing the root node of all the piece CIDs contained in the sector.</p>
<ol start="2" type="1">
<li><p><strong>Sealing sectors and producing the Commitment of Replication</strong></p>
<p>Sector data is encoded through a sequence of graph and hashing processes to create a unique replica. The root hash of the merkle tree of the resulting replica is called CommRLast. CommRLast is then hashed together with the CommC(another merkle root output from PoRep). This generates the CommR (Commitment of Replication) which is then recorded on Filecoin’s Blockchain. CommR, last is saved privately by the miner for future use in Proof of Spacetime but is not saved to the chain.</p>
<p>Encoding process is slow and computationally heavy. <strong>Filecoin doesn’t provide encryption by default so users must encrypt data before adding it to the Filecoin network.</strong> This is the first issue encountered with Filecoin : <strong>Filecoin is optimized for public data and doesn’t yet support access controls.</strong></p>
<p>The CommR offers clients the proof that the miner is storing a physically unique copy of the client’s data. If a client stores the same data with multiple storage miners, or makes multiple storage deals for the same data with the same miner, each deal will yield a different CommR. The sealing process also compresses the Proof of Replication using zk-SNARKs to keep the chain smaller so that it can be stored by all members of the Filecoin network for verification purposes.</p>
<p>Unlike PoRep which is run once to prove that a miner stored a physically unique copy of the data at the time the sector was sealed. PoSt is run repeteadly to prove that the miners are continuing to dedicate storage space to that same data over time.<sup>4</sup></p>
<h3 id="proof-of-spacetime" class="anchored">Proof of Spacetime</h3>
<p>PoSt builds on several elements created during PoRep: the replica, the private CommRLast and public Commr. PoSt then selects some leaf nodes of the encoded replica and runs merkle inclusion proofs on them to prove that the miner has the specific bytes that indicate that he still holds the clients data. The miner then uses the privately stored CommRLast to prove that they know of a root for the replica which both agrees with the inclusion proofs and can be used to derive the CommR. As the final step PoSt compresses these proofs into a zk-Snark.</p>
<p>If the miners fail the Proof of Spacetime at any point they will lose their staked collateral. Aside for this fine, there is no other incentive to keep the miners storing the data. That becomes a problem if client’s storing private data or data of great significance.<sup>5</sup></p></li>
</ol>
</section>
</section>
<section id="results-discussion" class="level2">
<h2 class="anchored" data-anchor-id="results-discussion">Results &amp; Discussion</h2>
<section id="critique-from-the-users-perspective" class="level3">
<h3 class="anchored" data-anchor-id="critique-from-the-users-perspective">Critique From the users perspective:</h3>
<p>As of today the price of 1 Filecoin token (FIL) is $22.05. <strong>The users can store a gigabyte of data for as little as 0.0000006157315278020465 FIL (0.01% the cost of Amazon S3) which means the user can store 100GB of data for $0.00135.</strong><sup>6</sup> From the price perspective the upside of Filecoin is it’s cheap storage but there are various downsides such as:</p>
<ol type="1">
<li>Accesibility: if the user is not tech-savvy there is a big barrier to entry even with GUIs currently available. They are often not simple to install and it is hard to get them to work. Hovewer there are various Apps that make that somewhat easier like ChainSafe Files and Web3.Storage.When it comes to being a storage miner there minimal needs for hardware are:</li>
</ol>
<ul>
<li><p>8+ core CPU</p></li>
<li><p>128 GiB of RAM atleast</p></li>
<li><p>A strong GPU for SNARK computations</p></li>
<li><p>1TiB NVMe-based disk space for cache storage is recommended</p>
<p>This data shows that there needs to be a significant investment on storage miners part which is nothing out of the ordinary but significantly reduces the accessibility to the average person, ofcourse assuming the person wants to be a storage miner.</p></li>
</ul>
<ol start="2" type="1">
<li><p>As the price of FIL tokens fluctuate the price of storage fluctuates as well. There is also a risk if any extra FIL is left in the customers wallet after the storage contract then token could potentially drop/rise in value, not to mention the fees of converting fiat into cryptocurrency.</p></li>
<li><p>There is no built in encryption. Users need to encrypt their data on their own. Encryption/decryption of files cost compute resources (RAM, CPU), and therefore money. Most end users would prefer the implementation of this functionality to be handled, optionally, by the Filecoin web, cli or desktop client software they choose to make use of. This problem is seemingly taken care of with apps like ChainSafe Files.<sup>7</sup></p>
<p>ChainSafe Files is an online platform to store, view, and share files. Its main focus is data privacy of the users and self-reliance. When it comes to self-reliance ChainSafe Files makes sure that the users can access the stored files even if the Files platform becomes unavailable. It also offers authentication flow using a decentralized login provider called tKey, by Torus. tKey is a private key generator that can link keys to social accounts among other functions. The Files’ backend is built on top of ChainSafe Storage, and any file that is uploaded to Files is also pinned by a node on its infrastructure (each file has an CID) thus making the data retrieval possible even in the case of ChainSafe files app outage. In the case of retrieval users still have to decrypt the data, since all the data stored by ChainSafe Files is encrypted by default.<sup>8</sup></p></li>
<li><p>If the storage provider doesn’t respect his end of the deal he will be penalized and lose his staked FIL. Unless negotiating a great number of deals for the same data and storing a lot of copies in Filecoin, there is no guarantee that the data will be safely stored. These deals for the same data increase the cost of the service if the user wants to have somewhat durable data. Filecoin tries to mittigate this by having storage miners put 100+ FIL in collateral which also lowers the accessibility to the average person to become a storage miner. Currently most of the storage miners are located in China.</p></li>
<li><p>Filecoin storage is cold storage. There is no way to modify data. If the user needs to change data , new data must be written.<sup>9</sup></p></li>
<li><p>If the user issues a deletion command there is no guarantee that the client performs the operation. There is no way yet to Construct a formal Proof of Deletion.</p></li>
</ol>
</section>
<section id="the-issue-with-replication-and-filecoin" class="level3">
<h3 class="anchored" data-anchor-id="the-issue-with-replication-and-filecoin">The issue with Replication and Filecoin</h3>
<p>When decentralized storage network is utilized any storage node could go offline thus the stored data would be at risk of getting lost. To achieve a somewhat reliable storage many decentralized providers use replication, which means the only way to keep the users data reliably besides penalizing storage miners is to store multiple copies of it. Replication is not good for the network expansion factor. If Filecoin wants more durability for its data it needs more copies. For every increase of durability (storing or repairing the data) another multiple of the data size in bandwith is needed. Eg. If the durability level requires a replication strategy that makes 10 copies of the data this yields and expansion factor of 1000%. This data needs to be stored on the network, using bandwith in the process. The more replication the bigger the bandwith usage. Hovewer, if the node goes offline , only one of the storage nodes is needed to bring a new replacement node in, which again means that the 100% of the replicated data must be transferred. Excessive expansion factors produce an inefficient allocation of resources.<sup>10</sup></p>
<p>Another issue with replication is churn (nodes joining and leaving the network). Quoting Patrick Gerbes and John Gleeson: “Using replication in a high-churn environment is not only impractical, but inevitably doomed to fail. Distributed storage systems have mechanisms to repair data by replacing the pieces that become unavailable due to node churn. However, in distributed cloud storage systems, file repair incurs a cost for the bandwidth utilized during the repair process. Regardless of whether file pieces are simply replicated, or whether erasure coding is used to recreate missing pieces, the file repair process requires pieces to be downloaded from available nodes and uploaded to other uncorrelated and available nodes.”<sup>11</sup></p>
<p>Currently the circulating supply of FIL token is 162,302,978.00 FIL. The potential circulating FIL could reach 1.977 Billion tokens if the network hits a Yottabyte of storage capacity in under 20 years which is brave considering the current data stored in data centers today is less then a Zettabyte and a Yottabite is 1000 times larger. The 770 Million of which is for baseline minting.</p>
<p>330 million FIL tokens are released on a 6 year half-life based on time. A 6 year half-life means that 97% of these tokens will be released in aproximately 30 years. This amount is amount is minted to provide counter pressure to shocks.</p>
<p>Another 300 million FIL is held back in reserve to incentivize future types of mining. How they are released is up to the Filecoin community.<sup>12</sup></p>
<p><img src="https://3327.io/documents/research/posts/https:/filecoin.io/vintage/images/blog/filecoin-circulating-supply-minting.png" style="height: 250px; width:500px;"></p>
<p><em>Figure 1: Maximum and Minimum Minting from Storage Mining.</em></p>
<p><img src="https://3327.io/documents/research/posts/https:/filecoin.io/vintage/images/blog/filecoin-circulating-supply-baseline.png" style="height: 250px; width:500px;"></p>
<p><em>Figure 2: Network Storage Baseline for Max Baseline Minting on Log Scale.</em></p>
<p>As of today 29,180,207.338966275 FIL has been slashed.This means that if a network participant misbehaves, part of their FIL collateral or potential FIL rewards is confiscated and burned. FIL is also slashed for various other reasons.</p>
<p>Considering the token release we can expect total supply of FIL token to be almost doubled in the next five years. If we look the rate of slashing so far the dilluting process will exceed the tokens burned. This makes specullating Filecoin token price risky, both for the investors and users.<sup>13</sup></p>
</section>
</section>
<section id="filecoin-and-storj-comparission" class="level2">
<h2 class="anchored" data-anchor-id="filecoin-and-storj-comparission">Filecoin and Storj comparission</h2>
<p>We will compare Filecoin and Storj by: 1. Consensus Algorithms</p>
<p>Filecoin’s consesus mechanism has been covered in the paragraphs above.</p>
<p>Storj does not have its own chain: the platform is built on Ethereum(currently built on PoW). The reason they decided to build on the Ethereum network is because of simplicity of using it as a method exchange. From the start Storj was never intented to be a true decentralized storage network.</p>
<ol start="2" type="1">
<li><p>Block time</p>
<p>Filecoin’s block time is thirty seconds on average.</p>
<p>Storj is the only “decentralized storage” solution to not employ their own chain. Storj decided to use the Ethereum network due to the easy deployment of a coin on it. Because of this decision, the block time is twelve seconds and needs to deal with the consequences of sharing blockchain with other projects.</p></li>
<li><p>Enforcement of data retention</p>
<p>Due to the PoSt mentioned in the paragraphs above the entire network is designed around data retention. In the case of miner failing to keep his promise , the only backup of the user’s data was irreversibly lost since Filecoin doesn’t use redundancy which is also mentioned in the paragraphs above.</p>
<p>In Storj the actual enforcement of data isn’t clearly documented. Each Satellite (the interface between the storage operators and the clients) does the enforcement of data retention all on their own. Each Satellite has its own subset of storage nodes that it knows have a good reputation and it trusts, it uses these hosts to upload data to. Then it, at regular intervals, checks random data segments with “Berlekamp-Welch” error correction to make sure that the data is still there. If they fail to prove they store the data the reputation of that host is changed and data migrates to a new host. There is no chain-level enforcement for data retention.</p></li>
<li><p>Content distribution</p>
<p>In Filecoin data has to be sealed to be counted as a provable storage to the chain and because it is computation heavy it isn’t practical for the miners to serve data. 1 MiB file can take 5 to 10 minutes to unseal and 32 GiB file takes 3 hours on minimum hardware requirements mentioned above. To battle this Filecoin introduced a method to store cached and unsealed versions of data while storing the same data as sealed in order to provide proofs. This leads to the issue of miner storing the double amount of data while also posing the problem that unless the data is frequently accessed the miners will not store it because it isn’t profitable for them. That makes creating Google drive equivalent on Filecoin not practical because the data is not frequent enough to makes sense to cache while also being low latency (because of slow sealing and unsealing).</p>
<p>In Storj’s case data is being accessible only through the S3 gateway of centralized data data Satellites. Users can transform any data to public data and can send anyone a link to that data.</p></li>
<li><p>Sector size</p>
<p>Sector size is the minimum amount of data that can be sent to host and paid for. Filecoin has a fixed 32 GiB sector size. For each 256b stored 2b are proofs. Which means 1% of storage paid for is for proof. Also everything sent must be in a .car file which can be computationally heavy on the client-side.</p>
<p>In Storj’s case the sector size is not really clear. Current object fee is $0.0000022 per file stored. Which means that if there is a large amount of small files stored that would bring extra costs to the user.</p></li>
<li><p>Decentralization</p>
<p>Because of the Filecoin’s Hardware requirements for hosts that means not everyone can run a storage node. On the other networks basically anyone can run a storage node( most minimal requirements are 2 cores 8GB of RAM and some storage) but in Filecoin only people with sufficient funds for initial investments can run hosts which reduces the spread of the network. Which makes us question the actuall decentralization of the network.</p>
<p>Storj isn’t decentralized. The blockchain nature of the Storj coin is only designed for for efficient transacting not decentralized enforcement of data retention which means that Storj is actually a distributed storage provider but not fully decentralized.<sup>14</sup></p></li>
</ol>
</section>
<section id="filecoin-grants" class="level2">
<h2 class="anchored" data-anchor-id="filecoin-grants">Filecoin Grants</h2>
<p>Filecoin offers various types of grants for building with Filecoin.</p>
<section id="next-step-microgrants" class="level3">
<h3 class="anchored" data-anchor-id="next-step-microgrants">Next Step Microgrants</h3>
<p>Filecoin offers grants of 5000$ in FIL to support taking the next step when the initial prototype is created. Their purpose is financing projects in the early stage. Acceptance criteria is simple. Projects must meet these criteria:</p>
<ol type="1">
<li>Applicant has already built something with Filecoin (or closely related technologies such as IPLD, libp2p, or frameworks or services such as NFT.storage, Textile Powergate, etc.), independently or as part of a course or hackathon.</li>
<li>Applicant must provide clear description of the Next Step after grant support</li>
<li>The project can be completed within 3 months.</li>
<li>Project must be open-sourced.</li>
<li>The applicant must complete weekly updates and a grant report upon conclusion.</li>
</ol>
<p>Projects that qualify for Microgrants: 1. Projects that publish data or files to IPFS 2. Projects that don’t use IPFS directly 3. Projects that save data or retrieve data from the Filecoin Network 4. Non-coding projects, videos, tutorials etc</p>
<p>These grants are offered on the quarterly basis.</p>
</section>
<section id="open-grants" class="level3">
<h3 class="anchored" data-anchor-id="open-grants">Open Grants</h3>
<p>Filecoin’s focus areas currently are: 1. Core development - core protocol research, specification and implementation work 2. Application Development - applications that utilize Filecoin as a decentralized storage layer 3. Developer tools and libraries - tools and libraries for protocol developers and application developers 4. Integration and adoption - integration into existing app or projects with significant usage 5. Technical design - improvement proposals for the core storage protocol 6. Documentation 7. Community building 8. Metaverse - experiences, applications, communities, tooling, standards, infrastructure, et cetera<sup>15</sup> 9. Research that explores Filecoin and decentralized storage<sup>16</sup></p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>When it comes to decentralized storage solutions Filecoin draws all the attention compared to its competitors like Storj and Sia. Storj solves Filecoin’s replication problem, on the expense of decentralization but the internet search statistics still shows that Filecoin is the main contender in Decentralized storage.</p>
<p><img src="https://3327.io/documents/research/posts/https:/i.imgur.com/Lr2LaBi.png" style="height: 250px; width:500px;"></p>
<p><em>Figure 3. Filecoin (blue) vs Storj (red) search interest in the past 12 months.</em></p>
<p>Even with unclear tokenomics a nd problematic durability to the writer of this research, building with Filecoin seems like the best solution when building dApps that utilize decentralized storage because of its low cost and grant opportunities, even though storage miners are somewhat centralized. If there is a way to improve current storage miner’s/clients experience on Filecoin both in cost and ease of use that would surely be a great grant opportunity. Also there could potentially be a way to draw them to a protocol that is a cheaper alternative. Ofcourse, these are all assumptions, since much of the data on these protocol is unclear and not available.</p>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-fischPoRepsProofsSpace2018" class="csl-entry">
Fisch, Ben, <em>PoReps: Proofs of Space on Useful Data</em>, 2018 &lt;<a href="http://eprint.iacr.org/2018/678" class="uri">http://eprint.iacr.org/2018/678</a>&gt; [accessed 10 February 2022]
</div>
<div id="ref-olioReplicationBadDecentralized2018" class="csl-entry">
Olio, JT, ‘Replication Is Bad for Decentralized Storage, Part 1: Erasure Codes for Fun and Profit’, 2018 &lt;<a href="https://www.storj.io/blog/replication-is-bad-for-decentralized-storage-part-1-erasure-codes-for-fun-and-profit" class="uri">https://www.storj.io/blog/replication-is-bad-for-decentralized-storage-part-1-erasure-codes-for-fun-and-profit</a>&gt; [accessed 10 February 2022]
</div>
<div id="ref-WhyProofofReplication" class="csl-entry">
‘Why (<span class="nocase">Proof-of-</span>) Replication Is Bad for Decentralized Storage, Part 2: Churn and Burn’ &lt;<a href="https://www.storj.io/blog/why-proof-of-replication-is-bad-for-decentralized-storage-part-2-churn-and-burn" class="uri">https://www.storj.io/blog/why-proof-of-replication-is-bad-for-decentralized-storage-part-2-churn-and-burn</a>&gt; [accessed 16 February 2022]
</div>
</div></section><section class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p><strong>HttpsFileApp?</strong>↩︎</p></li>
<li id="fn2"><p><strong>FilecoinDocumentation?</strong>↩︎</p></li>
<li id="fn3"><p><strong>IPFSFilecoin?</strong>↩︎</p></li>
<li id="fn4"><p><strong>fischProofsReplication?</strong>↩︎</p></li>
<li id="fn5"><p>Ben Fisch, <em>PoReps: Proofs of Space on Useful Data</em>, 2018 &lt;&lt;http://eprint.iacr.org/2018/678&gt;&gt; [accessed 10 February 2022].↩︎</p></li>
<li id="fn6"><p><strong>HttpsFileApp?</strong>↩︎</p></li>
<li id="fn7"><p><strong>filecoinChainSafeFilesBuilding?</strong>↩︎</p></li>
<li id="fn8"><p><strong>ChainSafeFilesDecentralized?</strong>↩︎</p></li>
<li id="fn9"><p><strong>FilecoinFAQ?</strong>↩︎</p></li>
<li id="fn10"><p>JT Olio, ‘Replication Is Bad for Decentralized Storage, Part 1: Erasure Codes for Fun and Profit’, 2018 &lt;&lt;https://www.storj.io/blog/replication-is-bad-for-decentralized-storage-part-1-erasure-codes-for-fun-and-profit&gt;&gt; [accessed 10 February 2022].↩︎</p></li>
<li id="fn11"><p>‘Why (<span class="nocase">Proof-of-</span>) Replication Is Bad for Decentralized Storage, Part 2: Churn and Burn’ &lt;&lt;https://www.storj.io/blog/why-proof-of-replication-is-bad-for-decentralized-storage-part-2-churn-and-burn&gt;&gt; [accessed 16 February 2022].↩︎</p></li>
<li id="fn12"><p><strong>projectUnderstandingFilecoinCirculating?</strong>↩︎</p></li>
<li id="fn13"><p><strong>Filecoin?</strong>↩︎</p></li>
<li id="fn14"><p><strong>StorageChainsCompared?</strong>↩︎</p></li>
<li id="fn15"><p><strong>filecoinFilecoinPolygonStudios?</strong>↩︎</p></li>
<li id="fn16"><p><strong>labsFilecoinGrants?</strong>↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-38.gfm.html</guid>
  <pubDate>Thu, 24 Feb 2022 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Solidity++ (S++)</title>
  <dc:creator>Aleksandar Veljković</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-57.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level1">
<h1>Executive Summary</h1>
<p>Writing efficient code in modern languages is mostly reflected in writing efficient algorithms and business logic. Writing efficient code in Solidity is mostly reflected in thinking as an assembler, moving focus from logic implementation to memory optimisations and low level hacks. Highly optimised code may become unreadable and unmaintainable with possible bugs hidden between the lines of bit level operations. To solve this problem, this project proposes multiple automatic optimisation techniques that will be all summed up into a transpiler and Solidity language extensions called Solidity++.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Javascript introduced classes in ES6 which are very useful construct for writing clean and readable code. Browser, however, could not understand ES6 code so the code needed to be transpiled into ES5. Programmers could use classes to write logic and transpiler took care of transforming the code into an optimised ES5. The same parallel could be made with Solidity. Programmers should be focused on writing business logic in Solidity-like S++ code and the code should be automatically transpiled into efficient Solidity code. S++ should not drastically modify basic Solidity syntax, but introduce new annotations and helper functions that would enable efficient transpiling to pure Solidity code.</p>
<p>There are multiple ways to improve the smart contract code on bytecode level. This project will focus on improvements on Solidity code level but the end product - optimised Solidity code will be compiled into bytecode and further optimisations on bytecode level can be performed.</p>
<p>Optimisations on code level include variable declaration ordering (state variables, local variables and structs), which correlates with the order of memory block stacking and directly influences the costs of storing the data. Some variables might occupy more space than needed to store values in ranges that require less bits than the closest Solidity data type. The most extreme example is boolean data type which stores true/false values, that could be stored in 1 bit of memory, but really use an entire byte. Accessing storage structs requires more operations than accessing a local variable, which becomes obvious problem when it is done in loops. Any fixed sized data type, like, int64, bytes32 and so on, are always cheaper than dynamic data types, such as string, and those dynamic types should be replaced with fixed ones wherever is possible (wherever the value range of the variable is known). Cost reduction can even be achieved by deleting variables - freeing blockchain space. Execution of a code that performs <em>delete</em> command on some variable/mapping value/… rewards executor with a refund of up to 50% of transaction cost, depending on the amount of freed space. There were some attempts to remove this feature (https://eips.ethereum.org/EIPS/eip-3298) but so far it is still valid and exploitable. Usage of lazy evaluation is, an in other languages, preferred way of saving execution steps, which for Solidity directly equals saved money.</p>
<section id="existing-solutions" class="level3">
<h3 class="anchored" data-anchor-id="existing-solutions">Existing solutions</h3>
<p>There are optimisations on loop level [1] that do not include variable level optimisations but recognise code patterns that are classified into several categories that can be automatically optimised. Also, there are papers [2] that uncover additional space for optimisation, such as removing conditions that always equal the same value or values in the loops that never change. There are also blog advices for writing optimised smart contracts, such as [3], that can and will be referenced when implementing automatisation methods.</p>
</section>
</section>
<section id="goals-methodology" class="level1">
<h1>Goals &amp; Methodology</h1>
<p>So far, there is no tool or IDE that either automates these optimisations or includes multiple improvements in one software. The goal of this project is to evaluate feasibility of implementing such tool and Solidity language extensions that could allow its easier implementation. End PoC toll planned as a result of this project focuses on space optimisation techniques and includes: * Implementing parser for Solidity language that enables language semantic and syntax analysis * Implementing optimisation methods: * Variable declaration reordering * Struct values declaration reordering * Defining data type extensions for storing custom-sized data (i.e.&nbsp;integers with values between 20 and 40) and implementing language parser extensions * Implementing generator for optimised code</p>
</section>
<section id="results-discussion" class="level1">
<h1>Results &amp; Discussion</h1>
<p>Proto-parser for Solidity code, which includes basic PoC constructs was implemented, as well as variable declaration reordering to enable more efficient space usage; The plan is to extend the parser and to include other optimisation techniques listed in the previous segment.</p>
<section id="variable-declaration-reordering" class="level3">
<h3 class="anchored" data-anchor-id="variable-declaration-reordering">Variable declaration reordering</h3>
<p>Variable declaration reordering is a problem synonymous to binning problem, where the goal is to pack objects of a certain size into bins of fixed size <em>in any order</em> using the least number of bins. The problem is a known optimisation problem which comes from NP (non-deterministically polynomial) class and has no known efficient solution. The approach for implementing variable declaration reordering was using branch-and-bound algorithm which resulted in decent reordering time of less than 10 seconds for up to 16 variables in one block. The reordering was performed per block. The same algorithm will be performed on structs.</p>
</section>
<section id="data-type-extensions" class="level3">
<h3 class="anchored" data-anchor-id="data-type-extensions">Data type extensions</h3>
<p>To enable extensions of data types there are two steps: * Defining language extensions * Map variables to bits of memory blocks and create getters and setters</p>
<p>New data types will be mapped to memory blocks, variables of 256 bits, on bit level using bit masks. Packing of those values will be optimised using the previously defined variable stacking algorithm</p>
<p>Proposed language extension of integer data types consists of using the existing base type (int, uint) followed by value range given in brackets. Example custom type uint&lt;10, 1030&gt; represents unsigned integer values between 12 and 98. The optimiser would determine the closest known data type that covers the range (in this case uint16). The real number of bits required to store value 1030 is 11 and the closest data type is 16 bits long which means that 5 bits are redundant. First level of optimisation may be using 11 bits mapped to a memory block of 256 bits and implementing getters and setters to interact with the value, which is casted to uint16 when used. But there is another hidden optimisation that can further improve space management. Notice that the upper limit of the interval is indeed 1030 which required 11 bits to store but the lower limit is 10 which means that total number of values is 1030 - 10 = 1020 and that many values can be stored in 10 bits of memory, so the optimisation will take into account the overall interval range and generate getters / setters that will include offsets before storing/loading values.</p>
<p>Boolean type optimisation will be straight forward and, while it will keep the type name, it will be mapped to only one bit of memory.</p>
<p>String data types would be extended with indicator of the number of characters as string&lt;10&gt; will represent fixed sized string that will be mapped to bytes.</p>
</section>
<section id="code-generation" class="level3">
<h3 class="anchored" data-anchor-id="code-generation">Code generation</h3>
<p>The parser generates three-like structure of the Solidity code. Every statement or declaration is stored as an object with parameters related to the nature of the statement/declaration. For example, declaration uint256 private var1 is stored as VariableDeclaration object with attributes type=uint256, modifier=private identifier=var1. Each object contains information to reconstruct itself back to string from. This type of organisation enables easy traversal through code, easy recognition of higher-level constructs, such are infinite loops, and easy reconstruction to Solidity code (in this case - optimised code).</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>The feasibility of the proposed project is confirmed by implementing PoC prototype, the optimisation evaluation on the existing smart contracts is yet to come but even the simple reordering of variables that reduces the number of used memory blocks clearly shows benefits of money savings (saved memory) and time savings (eliminated thinking about such generic problem that can and should be automatised). The borderline is - it makes no harm to use it, it can only be an improvement.</p>
<p>The value of this project is assumed, but still has to be confirmed. That is why the next step of this research should be further assessment by target user group, which should include developers that are actively using Solidity in their everyday work and domain experts. # Appendices</p>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>
<p>[1] B Mariano, Y. Chen, Y. Feng <em>Demystifying Loops in Smart Contracts</em> https://fredfeng.github.io/papers/ase20-consul.pdf</p>
<p>[2] T.Brandstaetter <em>Optimisation of Solidity Smart Contracts</em> https://repositum.tuwien.at/bitstream/20.500.12708/1428/2/Brandstaetter%20Tamara%20-%202020%20-%20Optimization%20of%20solidity%20smart%20contracts.pdf</p>
<p>[3] https://mudit.blog/solidity-gas-optimization-tips/</p>


</section>
 ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-57.gfm.html</guid>
  <pubDate>Wed, 23 Feb 2022 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Gaming DAPPs - Play to Earn model</title>
  <dc:creator>Milos Bojinovic</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-37.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level1">
<h1>Executive Summary</h1>
<p>Blockchain games, also called Gaming DAPPs, are an emerging area in the Web3 space. With their gameplay, Gaming DAPPs currently cannot compete with the 3D AAA games and they mostly resemble 2D Hyper Casual Mobile games. Developers often need to make compromises in separating on-chain activity from the actions that are taken off-chain and so the line is blurred between what is truly a blockchain game and what is not. However, strong advantage of these games is that they almost always offer some form of an economic incentive to the players with an opportunity to “own” part of the game in order to influence the game’s further development.</p>
<p>The most widespread model in such games is the “Play to Earn” (P2E) model. In a P2E model, players compete against each other in earning either ERC721 or ERC20 tokens. The mechanism of token distribution varies from game to game but in general it favors those that invest more into the game and so the “Pay to Win” element is introduced. This is currently the most popular model but it has negative connotations of lacking the play aspect and focusing on just the earning potential. Games now try to pivot to what they call “Play and Earn” model with the intention of promoting the community first but also keeping the earning part going. In either way, the economy of such games seems unsustainable as it relies on the never ending stream of new players.</p>
<p>Onboarding process is also almost always a bit complex and pricy. In order to start playing, the player initially needs to bare some cost that is not constant and is decided by the market (i.e.&nbsp;buying ERC721 tokens used in the game).</p>
<p>For the gamers to accept those low quality games, those tradeoffs and a pricy onboarding process there would need to be an economic incentive and whatever the future models will be called the earning aspect needs to be present.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Gamers expect interactivity from the games they play. Once an action is taken in the off-chain games, the feedback signal is quick and the gamer knows nearly instantly the consequences of that action. Translating this experience to on-chain games is extremely difficult as every interaction that alters the state involves a transaction. Those transactions cost some amount of tokens native to the chain but they also take some time to process. This affects the whole game design process as the number of transactions that are required to advance the state in the game should be kept to a reasonable number. Having the player’s balance getting continuously decreased while playing the game and breaking the flow of it with the popup needed to sign each transaction will result in that player questioning the whole utility of that game. If the game doesn’t take this seriously into account it will lead to a bad user experience.</p>
<p>Due to current blockchain limitations, games try to cheat their way out of this by having the game logic on the server with players just signing the messages or transactions associated with their in-game actions. Splinterlands<sup>1</sup> is a popular game and an example of such practice. It is developed on the Hive blockchain<sup>2</sup> that does not support smart contracts and so the rules of the game need to be kept on the server.</p>
<p>Another successful game, Axie Infinity<sup>3</sup> takes the approach of having the players register an user account that will be linked to their wallet’s address. Almost every action inside the game is done via the PC or a Mobile client where the player has logged in with their user account. The server is in control of this game’s logic as well, which poses a huge problem because the rules of the game can be altered by the developers.</p>
<p>One important part of the Axie Infinity’s economy relies on ERC721 tokens (called “Axies”) that are used inside the game. Axies can be traded on the Axie Marketplace and are needed when minting new tokens so some players focus purely on this aspect of the game. The main game’s mechanic are “Player vs Player” (PvP) matches. The winner of the match gets some amount of game’s ERC20 tokens that depends on the player’s rank. The higher the rank the bigger the rewards. To increase their rank, players need stronger and better Axies which leads them back to the marketplace. The similar model is used across the industry, like in Pegaxy<sup>4</sup> which is a competitor game on Polygon that is currently gaining traction.</p>
<p>Because Axie Infinity was one of the first P2E games, is still relevant today and its solutions are being used in other games, this paper takes it as a study case, doing a deep dive into its inner workings.</p>
</section>
<section id="goals-methodology" class="level1">
<h1>Goals &amp; Methodology</h1>
<p>Being a pioneer in the space, Axie Infinity had to make some compromises. This resulted in combining the actions that are taken on-chain that include trading, minting and paying out the winnings with the off-chain actions like playing a match.</p>
<p>Having a hybrid or completely centralized approach defeats the purpose of a blockchain. The goal of this research is to understand the game’s mechanics and to try to answer the question if this and similar games can be built purely on-chain. It does this by breaking down the rules of the game and then proposing on-chain solutions.</p>
<p>In this research, there are sections dedicated to the basics of the economic model of the game. However, it is not the goal of this paper to delve deep into its problems and possible approaches to solving them. This model and its variations would require a separate research and the intention of those sections is just meant to provide context to the reader.</p>
</section>
<section id="results-discussion" class="level1">
<h1>Results &amp; Discussion</h1>
<section id="ronin-sidechain" class="level2">
<h2 class="anchored" data-anchor-id="ronin-sidechain">Ronin sidechain</h2>
<p>The game was developed on Ethereum in 2018 by the Sky Mavis company located in Vietnam. Due to high Ethereum fees, the game’s creators moved to their own EVM compatible sidechain called Ronin which uses Proof of Authority with validators being chosen by the company<sup>5</sup> .</p>
<p>To start playing a player needs to :</p>
<ul>
<li>create their own Ronin wallet</li>
<li>create their user account on the Axie Marketplace and connect their wallet to it</li>
<li>transfer some amount of ETH and buy at least 3 Axies with a floor price of ~42 dollars per Axie</li>
<li>install a PC or Mobile app and <strong>login with their user account</strong></li>
</ul>
<p>Disregarding the difficulty of the onboarding process, the whole point of a blockchain game is to have the players take actions on the blockchain. Some arguments could be made that at the time the game was developed this was needed but with the introduction of Ronin it is unclear why the whole game was not ported to it.</p>
<p>The only actions that are taken on the Ronin sidechain are dedicated to trading - buying, minting and gifting of Axies. There are no fees on Ronin, but the number of transactions per wallet address per day is limited. Deploying on Ronin, also, requires company’s permission so the development of new games and the whole Ronin ecosystem is slowed down.</p>
</section>
<section id="scholarships" class="level2">
<h2 class="anchored" data-anchor-id="scholarships">Scholarships</h2>
<p>Market decides on the price of Axies and with a high entry cost of starting with the game, a new model of onboarding has emerged. Newcomers (scholars) can “rent out” the Axies for a certain period of time and negotiate with the owners (managers) the terms of the profit distribution. This is not a official in-game feature and is enabled by having the managers controlling the Ronin wallet and scholars controlling the user account associated with it. This leads to a bad position for the scholar as the profits are claimed by the manager and then the scholar’s share is sent to the their wallet’s address. Scholars are essentially at the mercy of the managers as their earnings and the scholarship itself can be revoked at any time.</p>
<p>More fairer way of enabling Scholarships, would be to have a smart contract that would have complete control of the Axies and through which the scholars would make in-game actions. The profits would go to the contract’s address that would perform a fair split. The terms of the agreement (the minimum amount of profits to be earned by the scholar) and the scholarship’s time period would be embedded in the contract. If both parties agree, the terms could be changed later on.</p>
</section>
<section id="game-breakdown" class="level2">
<h2 class="anchored" data-anchor-id="game-breakdown">Game Breakdown</h2>
<p>The game itself is organized in 1v1 matches where players do not have any influence against who they will get matched. Matching is done by the server based on players’ Match Making Rankings (MMR) which is determined by the win/lose ratio of those players. All of this could be implemented in a smart contract which would keep track of all of the players’ MMRs and update them after each match. Players could start a new match or join an existing one if the absolute difference in their MMRs is under a certain threshold. The benefits of this approach is that they could also choose what match they will join or challenge a specific player.</p>
<p>Winner of each match gets some amount of game’s “Smooth Love Potion” (SLP) tokens. That amount is dependent on the MMR of that player (the higher the MMR the more SLP tokens they will win). SLP is an inflationary ERC20 token that gets minted after each match. Even though there are SLP burning mechanisms through some in-game actions, most players opt to cash out their winnings so this might not be a viable economic model. One alternative would be to have both players stake some amount of tokens in a match with the winner taking the sum of those stakes. The problem is that it introduces betting connotations and games go to extreme lengths in order to not be considered a betting game as it potentially introduces regulation.</p>
<p>Inside the game, there is also “Axie Infinity Shard” (AXS) token. AXS is an ERC20 token which has a fixed total supply. The company behind the game has roughly 20% of the total AXS supply and small amounts of AXS is distributed to the top players of the month.</p>
<p>The game makes heavy use of Axies which have certain characteristics. Players do not completely own Axies as it was discovered that the company can freeze them, making them useless. Once an Axie is frozen, it cannot be used in the game nor it can be traded on the Axie Marketplace. This possess a major concern as the players’ assets are constantly under a threat of those players being banned from the game by the Sky Mavis company. Full list of violations that will result in a ban can be seen here<sup>6</sup> .</p>
<p>Each Axie has one of the 9 classes, 4 statistics and 4 cards associated with it. Classes are grouped into three groups that form a “rock paper scissor” relationship. Meaning that, group G1 does 15% extra damage to group G2 but takes 15% extra damage when attacked by group G3. Statistics determine the Health, Skill, Speed and Morale of an Axie. This statistics affect the matches and their state transitions as the Speed for example determines the order of attacks. Cards can have positive or negative effects on an Axie as well additional effects that affect the players. Four cards associated with an Axie are added to the player’s deck when that Axie is used inside a match. More information about Axies is provided in Appendix A and the way new Axies are created is provided in the Breeding section of the Whitepaper<sup>7</sup> .</p>
</section>
<section id="matches" class="level2">
<h2 class="anchored" data-anchor-id="matches">Matches</h2>
<p>One match consists out of:</p>
<ol type="1">
<li>Both players choosing a team of 3 Axies and deciding on their positions on the field (creating team formations)</li>
<li>Rounds being played out until one of the players doesn’t have a standing Axie</li>
</ol>
<center>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/assets/ERFC-37/AxieMatch.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
<p><em>Picture 1 : Axie Infinity Match View</em></p>
</center>
<section id="team-formations" class="level3">
<h3 class="anchored" data-anchor-id="team-formations">Team formations</h3>
<p>The positioning of an Axie matters because it determines what Axie will take the damage from the enemy. Each player has 5 rows where an Axie can be positioned. The closest row to the enemy lines will be attacked first. The Axies cannot change their position and they stay where they initially were until they get knocked out. Choosing of a team formation would require two transactions per player. Those transactions would be organized in the commit-reveal scheme so that the players wouldn’t have an advantage against the opponent that naively sent the transaction revealing their team and their positions.</p>
</section>
<section id="rounds" class="level3">
<h3 class="anchored" data-anchor-id="rounds">Rounds</h3>
<p>Each Round is carried out in the following order:</p>
<ol type="1">
<li>Players randomly draw 3 cards* from their own decks (consisting of 24 Cards**) and decide on what cards they will play</li>
<li>Cards are revealed and their affects are applied to Axies</li>
<li>Battle of the Round takes place</li>
<li>If one of the players doesn’t have a standing Axie then the match is over</li>
</ol>
<p>* Exception is that in the first Round, players draw 6 cards.</p>
<p>** There are 3 Axies per team, each Axie adds two copies for each of the 4 cards. So in total there are 3*2*4 = 24 cards in one player’s deck.</p>
</section>
<section id="drawing-of-cards" class="level3">
<h3 class="anchored" data-anchor-id="drawing-of-cards">Drawing of Cards</h3>
<p>Once the teams have been revealed both players know each other decks. However, they should not know what cards the opponent has in their hands and so they should not know what cards they have yet to draw.</p>
<p>One scheme that could be applied is the following:</p>
<ol type="1">
<li>Have both players choose their secret “random” number and commit to it with a hash</li>
<li>Have the game’s contract ask for a random number from Chainlink’s VRF<sup>8</sup></li>
<li>Once the randomness has been fulfilled, both players know what is the order of cards they will be drawing as the seed for shuffling their decks will be some function of their own number and the received number from Chainlink’s VRF</li>
</ol>
<p>The drawing order of cards in the deck is now known only to the players. During the match, each player can play any card inside their deck and until a match ends, players trust each other that the played card was in the opponent’s hand. However, when the match ends both players would need to reveal their secret numbers as the contract needs to verify if they honored the drawing order and if the card they played at a certain moment was one of the cards they were holding. The first discrepancy would end the verification process and the cheater would be penalized.</p>
<p>One additional subproblem is that after each round the remaining cards inside the deck should be reshuffled. This could be done with requesting another random number which would help form a seed for random shuffling of the remaining cards. The verification process would need to be modified to support this.</p>
<p>Note: after all of the cards have been drawn, the deck resets.</p>
</section>
<section id="reveal-of-the-cards" class="level3">
<h3 class="anchored" data-anchor-id="reveal-of-the-cards">Reveal of the Cards</h3>
<p>The reveal of the cards would also need two transactions per player so that one player wouldn’t just wait for the opponent to reveal their cards and then change their strategy accordingly.</p>
<p>Once cards have been revealed, before the battle takes place, the effects of the played Cards are applied. In total there are 3 constant effects (Attack damage, Defensive points and the cost of playing that Card) and 19 additional effects that a Card may have. For example, one of those additional effects are an increase/decrease in one of the Axie statistics. When multiple Cards that affect the same Axie are played, their effects are accumulated. More information about cards is provided in Appendix A .</p>
</section>
<section id="battle-of-the-round" class="level3">
<h3 class="anchored" data-anchor-id="battle-of-the-round">Battle of the Round</h3>
<p>Battle rules:</p>
<ul>
<li>the order of attacks is determined by the highest Speed statistic (if there is a draw then it is decided by the lowest Health and then by lowest ID of an Axie)</li>
<li>closest row with a standing Axie to the enemy lines will take the damage</li>
<li>if two Axies are inside the row taking the damage there’s a 50/50 chance which Axie will absorb the damage</li>
</ul>
<p>All of this logic could be kept inside a contract. One of that things that would need to be taken into account is that Axies attack in the pre-defined order. So during a Round, an Axie that has not yet attacked could be knocked out of the game and so the Cards associated with it, that were played in the Round, should lose their effects. Also, when an Axie gets knocked out, all of their cards should be removed from the deck.</p>
</section>
</section>
<section id="summary-of-proposed-matched-progression" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-proposed-matched-progression">Summary of proposed matched progression</h2>
<section id="inital-proposal" class="level3">
<h3 class="anchored" data-anchor-id="inital-proposal">Inital proposal</h3>
<center>
<table class="table">
<colgroup>
<col style="width: 4%">
<col style="width: 11%">
<col style="width: 48%">
<col style="width: 18%">
<col style="width: 17%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Step</th>
<th style="text-align: center;">Phase</th>
<th style="text-align: center;">Description</th>
<th style="text-align: center;">Number of transactions</th>
<th style="text-align: center;">Done by</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">Match Set Up</td>
<td style="text-align: center;">Starting of a Match</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Player 1</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">Match Set Up</td>
<td style="text-align: center;">Joining a Match</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Player 2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">Match Set Up</td>
<td style="text-align: center;">Committing to a team formation and setting of a secret number</td>
<td style="text-align: center;">2*1</td>
<td style="text-align: center;">Player 1 and Player 2</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">Match Set Up</td>
<td style="text-align: center;">Revealing team formations</td>
<td style="text-align: center;">2*1</td>
<td style="text-align: center;">Player 1 and Player 2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">Round</td>
<td style="text-align: center;">Committing to Cards that will be played in this Round</td>
<td style="text-align: center;">2*1</td>
<td style="text-align: center;">Player 1 and Player 2</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">Round</td>
<td style="text-align: center;">Revealing Cards of the Round</td>
<td style="text-align: center;">2*1</td>
<td style="text-align: center;">Player 1 and Player 2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">Match Wrap Up</td>
<td style="text-align: center;">Revealing secret numbers after the match has ended</td>
<td style="text-align: center;">2*1</td>
<td style="text-align: center;">Player 1 and Player 2</td>
</tr>
</tbody>
</table>
</center>
<p><strong>Total</strong> = (1+1+2+2) + N*(2+2) + (2) = 8 + 4*N ; where N is the number of rounds in the match</p>
<p>Even with just 3 rounds the number of transactions per player would be 16, so this is a problem.</p>
</section>
<section id="improved-match-progression" class="level3">
<h3 class="anchored" data-anchor-id="improved-match-progression">Improved Match Progression</h3>
<p>Something that could be done is the introduction of “fair play” where for one round’s commit stage, one player would transmit both of the commit messages to the chain after which the other player would transmit both reveal messages.</p>
<p>If the player transmitting commitment messages decides to not transmit them, then the match is stuck. However, the game can be structured in a way such that it is in the interest of both players to resolve the match regardless of the outcome. This could be done by staking some amount of tokens that the players will receive at the end of the match.</p>
<p>If the player transmitting the reveal messages realizes he will lose and decides to not transmit them, then the first player could transmit just their own reveal message that would start a countdown for the other player to transmit their reveal message. If the countdown is reached then the player that didn’t act in the spirit of fair play is penalized in some way.</p>
<center>
<table class="table">
<colgroup>
<col style="width: 4%">
<col style="width: 11%">
<col style="width: 59%">
<col style="width: 17%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Step</th>
<th style="text-align: center;">Phase</th>
<th style="text-align: center;">Description</th>
<th style="text-align: center;">Number of transactions</th>
<th style="text-align: center;">Done by</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">Match Set Up</td>
<td style="text-align: center;">Starting of a Match</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Player 1</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">Match Set Up</td>
<td style="text-align: center;">Joining a Match</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Player 2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">Match Set Up</td>
<td style="text-align: center;">Transmitting commitments to the team formations and setting of a secret number</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Player 1</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">Match Set Up</td>
<td style="text-align: center;">Transmitting the Reveal of team formations</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Player 2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">Round</td>
<td style="text-align: center;">Transmitting Commitment Messages</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Player 1</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">Round</td>
<td style="text-align: center;">Transmitting Reveal Messages</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Player 2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">Match Wrap Up</td>
<td style="text-align: center;">Revealing secret numbers after the match has ended</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Player 1</td>
</tr>
</tbody>
</table>
</center>
<p>This scheme would give the total number of transactions of:</p>
<p><strong>Total</strong> = (1+1+2) + N*(2) + (1) = 5 + 2*N ; where N is still the number of rounds in the match</p>
<p>With the number of rounds equal to 3, the number of transactions per player is less or equal to 6.</p>
<p>This is an improvement but maybe it could be brought down further. Also, signing 6 transactions per match would still break the flow of the game, so the players would have to have a substantial financial interest in continuing to play the current match and the game itself.</p>
</section>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Developers should keep realistic expectations on what games can be built purely on the blockchain and they should convey those expectations transparently to the end users. Proposed on-chain solutions from this research can be improved and adjusted to fit similar games. The current bottleneck of all Gaming DAPPS is the number and speed of transactions needed, so the choice of a blockchain on which the games will be built, is extremely important. Hybrid approaches, in my opinion, should not be considered, but at the end of the day, the players will decide what games will be played. The most important thing is that the rules of the game cannot change by the will of the developers. The game’s logic should be kept in the smart contracts with the source code being public. This will keep everyone honest and the players would not be at the mercy of the developers.</p>
<p>Games are meant at meant to be fun but players ought to have an additional financial benefit from blockchain games because at this moment their user experience is hindered by the current blockchain limits as well as the lower quality graphics and player involvement. Everyone involved in the P2E model should view it as an investment first. Investments can be either good or bad and they depend on every party involved contributing to the end result. Once the investment has turned bad, investors should cut their losses if there is no indication that the situation will change. In this context that would result with the players quitting the game and moving to other games which leads to a bad word of mouth and it damages the whole ecosystem. A sustainable economic model needs to be embedded in the game itself so there should not be unbound minting of new tokens. However, how exactly should that future model look like would require serious thought and it should be a topic of a separate research.</p>
</section>
<section id="appendices" class="level1">
<h1>Appendices</h1>
<section id="appendix-a" class="level2">
<h2 class="anchored" data-anchor-id="appendix-a">Appendix A</h2>
<p>Each Axie has a fixed set of attributes - a class, 4 stats and 4 cards.</p>
<center>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://3327.io/documents/research/assets/ERFC-37/Axie.png" class="img-fluid figure-img"></p>
<p></p><p></p>
</figure>
</div>
<p>Picture 2: Axie characteristics</p>
</center>
<section id="axie-classes" class="level3">
<h3 class="anchored" data-anchor-id="axie-classes">Axie Classes</h3>
<ul>
<li>9 of them <strong>(Plant, Reptile, Dusk, Beast, Bug, Mech, Aqua, Bird, Dawn)</strong></li>
<li>6 main classes (Plant, Beast, Bug, Reptile, Aqua, Bird, Dawn)</li>
<li>3 remaining are “secret” (and generally weaker in the game)</li>
<li>to make the strengths of classes balanced, they are grouped in 3 groups, forming a “rock paper scissor” relationship</li>
</ul>
</section>
<section id="axie-stats" class="level3">
<h3 class="anchored" data-anchor-id="axie-stats">Axie Stats</h3>
<ul>
<li><p>can be divided into “base” and “additional” Stats</p></li>
<li><p>total of 140 points is distributed between 4 of the base Stats (with each class having its own base distribution)</p>
<ul>
<li><strong>Health</strong> — amount of damage Axie can take before getting knocked out</li>
<li><strong>Speed</strong> — affects the order in which Axies attack in a match (higher Speeds attack first)</li>
<li><strong>Skill</strong> — increases damage dealt when the Axie performs multiple cards/moves (a.k.a. combo)</li>
<li><strong>Morale</strong> — increases chance to land a critical hit, as well as entering “last stand” which allows them to attack a few more times before getting knocked out</li>
</ul></li>
</ul>
<center>
<p><strong>Base Stats Distribution</strong></p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Class</th>
<th style="text-align: center;">Health</th>
<th style="text-align: center;">Speed</th>
<th style="text-align: center;">Skill</th>
<th style="text-align: center;">Morale</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Aqua</td>
<td style="text-align: center;">39</td>
<td style="text-align: center;">39</td>
<td style="text-align: center;">35</td>
<td style="text-align: center;">27</td>
</tr>
<tr class="even">
<td style="text-align: center;">Beast</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">35</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">43</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Birds</td>
<td style="text-align: center;">27</td>
<td style="text-align: center;">43</td>
<td style="text-align: center;">35</td>
<td style="text-align: center;">35</td>
</tr>
<tr class="even">
<td style="text-align: center;">Bug</td>
<td style="text-align: center;">35</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">35</td>
<td style="text-align: center;">39</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Plant</td>
<td style="text-align: center;">61</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">41</td>
</tr>
<tr class="even">
<td style="text-align: center;">Reptile</td>
<td style="text-align: center;">39</td>
<td style="text-align: center;">35</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">35</td>
</tr>
</tbody>
</table>
</center>
<ul>
<li>additional Stats depend on Axie’s Body Parts</li>
</ul>
</section>
<section id="axie-body-parts" class="level3">
<h3 class="anchored" data-anchor-id="axie-body-parts">Axie Body Parts</h3>
<ul>
<li>there are 6 of them <strong>(Eyes, Ears, Horns, Mouth, Back, Tail)</strong></li>
<li>only Horns, Mouth, Back, Tail have an associated card with it (one card per body part)</li>
<li>In total, there are:
<ul>
<li>4*6 types of Mouth</li>
<li>6*6 types of Horns</li>
<li>6*6 types of Back</li>
<li>6*6 types of Tail</li>
</ul></li>
<li>inside groups of those types each of the 6 main classes is equally represented</li>
<li>if the class of an Axie matches with the type of a body part, Axie’s stats will increase</li>
</ul>
<center>
<p><strong>Additional Stats Increase</strong></p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Class/Type</th>
<th style="text-align: center;">Health</th>
<th style="text-align: center;">Speed</th>
<th style="text-align: center;">Skill</th>
<th style="text-align: center;">Morale</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Aqua</td>
<td style="text-align: center;">+1</td>
<td style="text-align: center;">+3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">+0</td>
</tr>
<tr class="even">
<td style="text-align: center;">Beast</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">+1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">+3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Birds</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">+3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">+1</td>
</tr>
<tr class="even">
<td style="text-align: center;">Bug</td>
<td style="text-align: center;">+1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">+3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Plant</td>
<td style="text-align: center;">+3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">+1</td>
</tr>
<tr class="even">
<td style="text-align: center;">Reptile</td>
<td style="text-align: center;">+3</td>
<td style="text-align: center;">+1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
</center>
<ul>
<li>An Axie is a ‘pure breed’ when its class and all of its body parts are of the same type.</li>
</ul>
</section>
<section id="axie-abilities-cards" class="level3">
<h3 class="anchored" data-anchor-id="axie-abilities-cards">Axie Abilities (Cards)</h3>
<ul>
<li>there are 132 cards in total (first divided by 6 main classes and then by the body parts)</li>
<li>each Axie has 4 cards associated with it</li>
<li>each Card has
<ul>
<li>an amount of Energy it costs to play it</li>
<li>attack points - damage it does to the enemy Axie</li>
<li>defensive points - forms a shield that takes the damage instead of Axie’s Health</li>
<li>potentially buffs/debuffs</li>
<li>additional effects (draw another card, steal some Energy from the opponent,…)</li>
</ul></li>
<li>cards realize a “combo” when 2 or more of them are played (for the same Axie)</li>
<li>cards realize a “chain” when 2 or more Axies use 2 or more cards that are from the same class</li>
</ul>
</section>
<section id="axie-card-buffsdebuffs-card-effects" class="level3">
<h3 class="anchored" data-anchor-id="axie-card-buffsdebuffs-card-effects">Axie Card Buffs/Debuffs (Card Effects)</h3>
<ul>
<li>there are 3 buffs (positive effects on the Axie) and 16 debuffs (negative effects on the enemy Axie)</li>
<li>they affect the Axie for one or more turns</li>
<li>they are “stackable” - their effects are accumulated</li>
</ul>
<center>
<p><strong>List of Buffs</strong></p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Attack+</td>
<td style="text-align: center;">Increase next attack by 20%</td>
</tr>
<tr class="even">
<td style="text-align: center;">Morale+</td>
<td style="text-align: center;">Increase Moral by 20% for the following round</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Speed+</td>
<td style="text-align: center;">Increase Speed by 20% for the following round.</td>
</tr>
</tbody>
</table>
<p><strong>List of Debuffs</strong></p>
<table class="table">
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Aroma</td>
<td style="text-align: center;">Target priority changes to this Axie until the next round.</td>
</tr>
<tr class="even">
<td style="text-align: center;">Attack-</td>
<td style="text-align: center;">Decrease next attack by 20%.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Chill</td>
<td style="text-align: center;">Affected Axie cannot enter Last Stand</td>
</tr>
<tr class="even">
<td style="text-align: center;">Fear</td>
<td style="text-align: center;">Affected Axie will miss their next attack</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fragile</td>
<td style="text-align: center;">Affected Axie’s shield will take double damage from the next incoming attack</td>
</tr>
<tr class="even">
<td style="text-align: center;">Jinx</td>
<td style="text-align: center;">Affected Axie cannot land critical hits</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Lethal</td>
<td style="text-align: center;">Next incoming attack is a guaranteed critical strike</td>
</tr>
<tr class="even">
<td style="text-align: center;">Morale-</td>
<td style="text-align: center;">Decrease Morale by 20% for the following round</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Poison</td>
<td style="text-align: center;">Affected Axie will lose 2 HP for every card used</td>
</tr>
<tr class="even">
<td style="text-align: center;">Sleep</td>
<td style="text-align: center;">Next incoming attack will ignore shields</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Speed-</td>
<td style="text-align: center;">Decrease Speed by 20% for the following round</td>
</tr>
<tr class="even">
<td style="text-align: center;">Stench</td>
<td style="text-align: center;">Affected Axie will lose target priority for the following round</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Stun</td>
<td style="text-align: center;">Affected Axie’s first attack will miss.Next incoming attack will ignore shields</td>
</tr>
<tr class="even">
<td style="text-align: center;">Cannot Be Healed</td>
<td style="text-align: center;">This Axie cannot be healed or recover health. This Debuff cannot be removed</td>
</tr>
</tbody>
</table>
</center>
</section>
</section>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-AxieInfinity" class="csl-entry">
‘Axie Infinity’, <em>Axie Infinity</em> &lt;<a href="https://axieinfinity.com/" class="uri">https://axieinfinity.com/</a>&gt; [accessed 24 February 2022]
</div>
<div id="ref-BreedingSLP" class="csl-entry">
‘Breeding and $SLP’ &lt;<a href="https://whitepaper.axieinfinity.com/gameplay/breeding" class="uri">https://whitepaper.axieinfinity.com/gameplay/breeding</a>&gt; [accessed 13 February 2022]
</div>
<div id="ref-IntroductionChainlinkVRF" class="csl-entry">
‘Introduction to Chainlink VRF | Chainlink Documentation’ &lt;<a href="https://docs.chain.link/docs/chainlink-vrf/" class="uri">https://docs.chain.link/docs/chainlink-vrf/</a>&gt; [accessed 13 February 2022]
</div>
<div id="ref-PegaxySummary" class="csl-entry">
‘Pegaxy Summary’ &lt;<a href="https://whitepaper.pegaxy.io/" class="uri">https://whitepaper.pegaxy.io/</a>&gt; [accessed 24 February 2022]
</div>
<div id="ref-RoninEthereumSidechain" class="csl-entry">
‘Ronin Ethereum Sidechain’ &lt;<a href="https://whitepaper.axieinfinity.com/technology/ronin-ethereum-sidechain" class="uri">https://whitepaper.axieinfinity.com/technology/ronin-ethereum-sidechain</a>&gt; [accessed 14 February 2022]
</div>
<div id="ref-Terms" class="csl-entry">
‘Terms’, <em>Axie Infinity</em> &lt;<a href="https://axieinfinity.com/terms/" class="uri">https://axieinfinity.com/terms/</a>&gt; [accessed 10 February 2022]
</div>
<div id="ref-SplintershardsSPSToken" class="csl-entry">
‘The Splintershards (SPS) Token’ &lt;<a href="https://sps.splinterlands.com/" class="uri">https://sps.splinterlands.com/</a>&gt; [accessed 24 February 2022]
</div>
<div id="ref-web3HiveBlockchainCryptocurrency" class="csl-entry">
Web3, Hive-The Blockchain &amp; Cryptocurrency for, ‘Hive - The Blockchain &amp; Cryptocurrency for Web3’, <em>Hive - The Blockchain &amp; Cryptocurrency for Web3</em> &lt;<a href="https://hive.io" class="uri">https://hive.io</a>&gt; [accessed 24 February 2022]
</div>
</div></section><section class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>‘The Splintershards (SPS) Token’ &lt;&lt;https://sps.splinterlands.com/&gt;&gt; [accessed 24 February 2022].↩︎</p></li>
<li id="fn2"><p>Hive-The Blockchain &amp; Cryptocurrency for Web3, ‘Hive - The Blockchain &amp; Cryptocurrency for Web3’, <em>Hive - The Blockchain &amp; Cryptocurrency for Web3</em> &lt;&lt;https://hive.io&gt;&gt; [accessed 24 February 2022].↩︎</p></li>
<li id="fn3"><p>‘Axie Infinity’, <em>Axie Infinity</em> &lt;&lt;https://axieinfinity.com/&gt;&gt; [accessed 24 February 2022].↩︎</p></li>
<li id="fn4"><p>‘Pegaxy Summary’ &lt;&lt;https://whitepaper.pegaxy.io/&gt;&gt; [accessed 24 February 2022].↩︎</p></li>
<li id="fn5"><p>‘Ronin Ethereum Sidechain’ &lt;&lt;https://whitepaper.axieinfinity.com/technology/ronin-ethereum-sidechain&gt;&gt; [accessed 14 February 2022].↩︎</p></li>
<li id="fn6"><p>‘Terms’, <em>Axie Infinity</em> &lt;&lt;https://axieinfinity.com/terms/&gt;&gt; [accessed 10 February 2022].↩︎</p></li>
<li id="fn7"><p>‘Breeding and $SLP’ &lt;&lt;https://whitepaper.axieinfinity.com/gameplay/breeding&gt;&gt; [accessed 13 February 2022].↩︎</p></li>
<li id="fn8"><p>‘Introduction to Chainlink VRF | Chainlink Documentation’ &lt;&lt;https://docs.chain.link/docs/chainlink-vrf/&gt;&gt; [accessed 13 February 2022].↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-37.gfm.html</guid>
  <pubDate>Wed, 23 Feb 2022 23:00:00 GMT</pubDate>
  <media:content url="https://3327.io//documents/research/assets/ERFC-37/AxieMatch.png" medium="image" type="image/png" height="90" width="144"/>
</item>
<item>
  <title>Access NFT Tools - Overview And Space For Improvements</title>
  <dc:creator>Milos Novitovic</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-40.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level1">
<h1>Executive Summary</h1>
<p>NFT Access tokens are primarily used to join private Discord and Telegram communities. Still, a significantly larger opportunity lies in many online and offline communities and events that might utilize this technology.<sup>1</sup></p>
<p>On the other side, there is a privacy concern with some tools that might be a deal-breaker. More precisely, tools used to identify whether a specific user holds an NFT might connect a user’s identity (e.g., Discord/Telegram name, SM account, etc.) with their wallet address and the amount of money they possess. Yet, we believe that ZK technology can be used to bridge that gap between privacy and utility.</p>
<p>However, before we deep-dive into creating a tech spec and building a PoC solution, we wanted to research whether our presumptions are correct, whether current collusion works as we assumed and whether there is space for technical improvement (innovation).</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This research is about understanding the state-of-the-art within the Access NFT tools niche, tools used to gate content (websites, blog posts, Discord, Telegram communities, etc.) and allow users to access it only if they hold a specific token (NFT).</p>
<p>Additionally, it is about verifying our presumption that there is privacy concern and space for technical improvement within current tools that allow access to Discord and Telegram communities.</p>
<p>Once the above is carried out, and if our presumption is confirmed to be accurate, we will have a chance to work on tech innovation, which will utilize the ZK technology.</p>
<p>Such a tool will do the same job as existing solutions by providing information to Discord and Telegram servers whether a specific user holds an NFT or not, but, it won’t keep track and centrally store connections between the users’ ID and their wallet addresses (the amount of crypto they possess).</p>
<p>Also, this research and idea are not about creating better and more user-friendly solutions. The current ones are fine from that point of view, but it is about creating more secure and privacy-improved solutions.</p>
</section>
<section id="goals-methodology" class="level1">
<h1>Goals &amp; Methodology</h1>
<section id="goals" class="level2">
<h2 class="anchored" data-anchor-id="goals">Goals</h2>
<ol type="1">
<li>Identifying content gating tools (that works).</li>
<li>Understanding how they work.</li>
<li>Recognizing use cases that they are used for, the problems they aim to solve.</li>
</ol>
<p>It is essential to overview current solutions in the field we aim to dive into. Both, short-term, for this research and experiment, ut also long-term, for being able to actively track all the innovation in this field from now on.</p>
<ol start="4" type="1">
<li>Verify our presumption about how current solutions are used to gate Telegram and Discord communities: Through using centralized services and storing the user’s private information (wallet address and username), existing solutions periodically verify the user’s possession of specific NFT.</li>
</ol>
<p>The main goal of this research is to verify our presumption that there is privacy concern and space for tech improvement within the Access NFT tool niche. If it is accurate, and if the current solution keeps track and connection between private users’ data, we can conclude that there are reasons to move forward with this idea and start working on technical specifications and research how it can be developed.</p>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<ul>
<li><p>Trying out and using existing solutions. We aimed to try each solution available on the market as we believe it is the only way to understand how it works and what problems it solves.</p></li>
<li><p>Consult and discuss with team and community members via contact forms or community servers We want to confirm that our understanding of how a specific tool works and what lies under the hood is correct. Hence, the best way is to receive confirmation from the people building and using it, especially when those tools are not open-sourced.</p></li>
<li><p>Analyze other reviews There are blog posts, websites, and apps that have already analyzed and gathered information about the current state of Access NFT tools. Thus, we do not need to do all of this work again, as we can benefit from their insights and overviews. Still, this does not mean that we will take it for granted. We want to do our research as well.</p></li>
</ul>
<p>*We were not looking under the hood (going through the code). Most of the solutions are not open-sourced. Also, we could understand how they work by consulting with the community and team members behind these solutions.</p>
</section>
</section>
<section id="results-discussion" class="level1">
<h1>Results &amp; Discussion</h1>
<p>First of all, our hypothesis/assumption appeared to be correct: By using centralized services and storing the user’s private information (wallet address and username), current solutions periodically verify the user’s possession of specific NFT. Thereafter they inform apps such as Discord and Telegram whether a particular user should be kept inside the Discord/Telegram channel or not.</p>
<p>There are 2 solutions used to gate access to the Discord and Telegram communities, Swordy-bot and Collab.Land. Additionally, there are other solutions used for content gating, but we will cover them later as we primarily focused on researching a solution used to verify whether the user owns a specific NFT required to access Discord and Telegram community channels or not and thereafter test our hypothesis.</p>
<section id="collab.land" class="level2">
<h2 class="anchored" data-anchor-id="collab.land">Collab.Land</h2>
<p><a href="https://collab.land/">Collab.Land</a> is a sovereign ruler and tool that is used by almost all Discord and Telegram Access communities.</p>
<p>The Collab.Land <a href="https://collab-land.gitbook.io/collab-land/bots/discord">documentation</a> is scarce and it is focused on explaining how to connect their bot rather than explaining how it works. Also, we could not find any other useful information and as their solution was not open-sourced, we reached out directly to them looking for answers that will help us test our hypothesis.</p>
<p>Based on the answers we received, Collab.Land does store connections between users personal information and their wallet address.</p>
<p>However, before we could conclude that our hypothesis was correct, we had to research Swordy-bot.</p>
</section>
<section id="swordy-bot" class="level2">
<h2 class="anchored" data-anchor-id="swordy-bot">Swordy Bot</h2>
<p><a href="https://swordybot.com/">Swordy-bot</a> is a Discord bot used to verify and grant access to a specific Discord channel (server) if a user has required token(s).</p>
<p>Compared to Collab.Land, Swordy-bot is built on top of decentralized Unlock Protocol. However, as well as Collab.Land it does store and keep a connection between user’s personal information (Discord id) and wallet address in their centralized database. We came to that conclusion (again) <a href="https://discord.com/channels/817286182890242059/817286182890242062/940232661773996043">based on the information</a> provided by their team members. .</p>
<p>Another common thing with Collab.Land is that Sowrdy-bot is not open-sourced as well.</p>
<p>Worth mentioning is that, even though Collab.Land is sovereign ruler, Swordy-bot is used as a gate keeper by more than 100 Discord communities.</p>
<p>Finally, we could confirm that our presumption was correct based on the fact that both of these solutions do store and keep track of the user’s wallet address and username centrally.</p>
<p>Thereafter we went a step further and analyzed other solutions used for content gating. All of them can be divided into 3 categories:</p>
<ol type="1">
<li>Protocols</li>
<li>Platforms</li>
<li>Apps/Tools</li>
</ol>
<p>Also each of them is either centralized or decentralized.</p>
<p>We have already covered Swordy-bot and Collab.land which are centralized tools.</p>
</section>
<section id="unlock-protocol-decentralized-protocol" class="level2">
<h2 class="anchored" data-anchor-id="unlock-protocol-decentralized-protocol">Unlock Protocol [Decentralized Protocol]</h2>
<p><a href="https://unlock-protocol.com/">Unlock Protocol</a> is an open-source protocol, not a centralized platform, used to create an underlying infrastructure for token gating content (communities, application, websites pages, and sections, images, videos, etc.)</p>
<p>It enables:</p>
<ul>
<li>user (admin) to deploy a set of smart contracts (on Mainnet, xDAI, Polygon, BSC, or Optimism) and define gating details (number of keys, key price and key duration).</li>
<li>regular users to purchase key (an NFT) and access content.</li>
</ul>
<p>UP is the underlying layer that allows other tools to build on top of it and utilize its functionalities. Bellow are listed use cases enabled through community-developed integrations (apps and plugins) build on top of Unlock Protocol:</p>
<ul>
<li><a href="https://docs.unlock-protocol.com/unlock/creators/plugins-and-integrations/discord">Swordy-bot</a> - gating Discord communities (servers and channels).<br>
</li>
<li><a href="https://unlock.community/t/unlock-discourse-plugin/64">Discourse plugin</a> - gated content on Discourse.</li>
<li><a href="https://docs.unlock-protocol.com/unlock/creators/plugins-and-integrations/wordpress-plugin">WP</a> and <a href="https://unlock-integration.webflow.io/">Webflow plugins</a> - gated website pages or section.</li>
<li><a href="https://www.drupal.org/project/unlock">Durap module</a> - gating content on Durap.</li>
<li>Slack plugin - gated Slack servers.</li>
<li><a href="https://github.com/pwagner/unlock-shopify-app">Shopify app</a> - allows merchants to offer special memberships to their customers.</li>
</ul>
<p>Plugins and other integration tools are the ones that connect blockchain with specific apps (Discord, Slack, etc.). Hence, they are centralized solutions that monitor what’s happening on a blockchain (whether the wallet address still holds an NFT) and inform apps about that. Something like reverse oracles.</p>
<p>All in all, Unlock Protocol is a customized set of smart contracts with the following functionalities:</p>
<ul>
<li>Minting and sending NFTs (locks) to users.</li>
<li>Collecting and withdrawing crypto on behalf of admin.</li>
</ul>
<p>Also, if needed, it can support more traditional (web2) authentication methods by storing private keys on behalf of a user. Also, UP support CC payments.</p>
<p>You are right if you think that all of the above may be done without UP. However, it is much easier and faster to implement all of these functionalities by using Unlock Protocol than developing all of the smart contracts and features from scratch.</p>
</section>
<section id="whale-room-centralized-platform" class="level2">
<h2 class="anchored" data-anchor-id="whale-room-centralized-platform">Whale room [Centralized Platform]</h2>
<p><a href="https://www.whaleroom.org/">Whale room</a> is a centralized platform that enables users to create their chat rooms within the platform and gate them by setting up the access requirements (required tokens). Also, it supports token mining and distribution (to the community members).</p>
<p>Whale room is an alternative for using Discord (or Telegram) in combination with Collab.Land (or Swordy-bot) as it offers both, chat rooms (as Telegram and Discord) and token gating functionality (as Collab.Land and Swordy-bot).</p>
</section>
<section id="mintgate-centralized-tool-platform" class="level2">
<h2 class="anchored" data-anchor-id="mintgate-centralized-tool-platform">MintGate [Centralized Tool &amp; Platform]</h2>
<p><a href="https://www.mintgate.io/">MintGate</a> is a tool that allows users to hide content (URL) and present it only to the ones that possess specific NFT. Users can use MintGate to deploy new NFTs required to access content, but it also supports using other NFTs, minted in the other way.</p>
<p>In addition, MintGate recently created a centralized platform that offers the creation of your store and gating it with MintGate technology.</p>
</section>
<section id="guild-centralized-platform" class="level2">
<h2 class="anchored" data-anchor-id="guild-centralized-platform">Guild [Centralized Platform]</h2>
<p>In combination with its Medusa bot, <a href="https://guild.xyz/">Guild</a> gate the access to Discord private channels rather than the whole discord server. Compared to other solutions, it supports more complex requirements logic by combining the following requirement options: possession of an NFT, amount of an ERC20 token, and opportunity to whitelist wallet addresses.</p>
<p>Besides this feature and difference, it offers the same options as using some of the previously mentioned bots combined with Discord or Telegram (that you also need if you want to use Guild).</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>After using available tools, going through their documentation, and discussing with their team members and community, we concluded that our presumptions are correct. There is a privacy concern as these tools are centralized solutions that store and keep the connection between users’ identity (Discord/Telegram names) and their wallet addresses.</p>
<p>The challenge is constructing the middle layer that connects blockchain and apps (Discord and Telegram) and making it more decentralized and anonymous. Today, those solutions are centralized bots that keep an eye on what’s happening on blockchain, whether wallet address (user) still holds an NFT, and inform apps about that. Something like “reverse oracles,” which tell the off-chain world what is happening on-chain or a protocol with similar specification that results in yes or no answers if the token is still in possetion.</p>
<p>Finally, based on the research and insights we gathered, we can conclude that there is a space for technical improvement and reason to move to the next step. The next step requires working on the decentralized and open-source solution that utilizes the ZK tech and provides the same functionality as current solutions. It checks whether users hold an NFT and informs Disord or Telegram about it without storing and keeping the connection between users’ identity (Discord/Telegram names) and their wallet addresses.</p>
<p>Precisely, solution has to:</p>
<ul>
<li>Know whether the user possesses a specific NFT (contract address, ID, Blockchain, Token Standard) and inform the Discord server about that</li>
<li>Recognize when a user does not possess NFT anymore and inform the Discord server about that. Ensure that the user has access to discord channels as long as he/she keeps NFT. Once NFT is no longer in possession of the user, he/she losses access to Discord channels.</li>
<li>Be open-source</li>
</ul>
<p>What solution must not do:</p>
<ul>
<li>Keep track (connection) between user’s wallet address and user (his discord/telegram username)</li>
<li>Allow more than one user to access Discord channels using the same NFT</li>
</ul>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-cowdreyAccessTokenNFTs2021" class="csl-entry">
Cowdrey, Ryan, ‘Access Token NFTs How They Work and What The Future Holds’, <em>NFT QT - QuHarrison’s NFT Newsletter</em>, 2021 &lt;<a href="https://www.nftqt.com/access-token-nfts-how-they-work-and-what-the-future-holds/" class="uri">https://www.nftqt.com/access-token-nfts-how-they-work-and-what-the-future-holds/</a>&gt; [accessed 27 January 2022]
</div>
</div></section><section class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Ryan Cowdrey, ‘Access Token NFTs How They Work and What The Future Holds’, <em>NFT QT - QuHarrison’s NFT Newsletter</em>, 2021 &lt;&lt;https://www.nftqt.com/access-token-nfts-how-they-work-and-what-the-future-holds/&gt;&gt; [accessed 27 January 2022].↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-40.gfm.html</guid>
  <pubDate>Sun, 20 Feb 2022 23:00:00 GMT</pubDate>
</item>
<item>
  <title>Analysis of smart contract fuzzers</title>
  <dc:creator>Marija Mijailovic</dc:creator>
  <link>https://3327.io/documents/research/posts/ERFC-42.gfm.html</link>
  <description><![CDATA[ 


<section id="executive-summary" class="level1">
<h1>Executive Summary</h1>
<p>We are witness of the accelerated development of smart contracts, and more and more valuable assets are contained in them. For this reason, it is very important to write secure smart contracts. However, since people write smart contracts, and people make mistakes, it is desirable to have a tool that will be able to point out potential problems in the code. Fuzz testing is a technique that with early entry stresses our program to reveal errors. We will get to know with fuzing tools through this research.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Smart contracts often contain valuable assets, whether in the form of tokens or Ether. Smart contract’s source code is publicly available, every execution happens on a public network. If smart contracts have vulnerabilities that can lead to catastrophic damages, that is potentially measured in millions of dollars. For example, at 2017 attack on Parity Wallet cost ~30 million dollars<sup>1</sup> , at the 2016 DAO Hack cost ~150 million dollars<sup>2</sup> , at 2020 Harvest Finance was attacked using flash loans and stole ~30 million dollars<sup>3</sup> . To prevent disasters like this, it is important to find any vulnerabilities in smart contracts before deployments. Some of the common vulnerabilities are integer overflow/underflow, race conditions, and also we could have logic mistakes that are hard to detect. Security is essential while developing smart contracts. There are some known hacker attacks and good practices to follow.<sup>4</sup></p>
<p>Hence, in the development of smart contracts, testing is one of the most important techniques that require special time aside. Mostly we write unit tests, but unit tests are specific to one use case, and often some edge cases are not covered. There is a big research interest in developing testing tools, especially ones that are able to automatically detect as many problems in the code as possible, one such technique is fuzz testing.</p>
</section>
<section id="goals-methodology" class="level1">
<h1>Goals &amp; Methodology</h1>
<p>There are many automatic bug-finding tools, and the purpose of this research is to introduce you to smart contracts fuzz testing. Fuzzing is a well-known technique in the security community it generates random, or invalid data as inputs to reveal bugs in the program, in one word it stress the program and causes unexpected behavior or crashes.</p>
<p>Considering the research interest in this area, a number of tools have been developed. Some popular open source tools are ContractFuzzer, ContraMaster, ILF, sFuzz, Smartian, and Echidna. Comparison of these tools is not easy task, the main reason is that each tool covers some specific set of bug classes.</p>
<p>Echidna is a property-based tool, develop with the aim to check if the contract violates some user-defined invariants, while other tool tries to find crashes. Company <em>Trails of Bits</em> extended fuzz technique to the EVM by developing the Echidna tool. Echidna can test both Solidity and Vyper smart contracts, it is written in Haskell, and main design goals are:</p>
<ul>
<li>Easy to use and configure</li>
<li>Good contract coverage</li>
<li>Fast and quickly results</li>
</ul>
<p>ContraMaster have been developed to detect irregular transactions due to various types of adversarial exploits, detects 3 classes of bug: Reentrancy, Exception Disorder, Gasless Send and Integer overflow/underflow.</p>
<p>ContractFuzzer detects 7 classes of bug: Reentrancy, Exception Disorder, Gasless Send, Timestamp Dependency, Block Number Dependency, DelegateCall and Freezing Ether Contract.</p>
<p>sFuzz detects all classes of bug as Contract Fuzzer plus Integer overflow/underflow. It has an extendable architecture which allows to easily support new bug classes as well. Also, sFuzz is effective in achieving high code coverage</p>
<p>Smartian detects 13 classes of bug: Assertion Failure, Arbitrary Write Block state Dependency, Control Hijack, Ether Leak, Integer Bug, Mishandled Exception, Multiple Send, Reentrancy, Suicidal Contract, Transaction Origin Use, Freezing Ether, Requirement Violation.</p>
<p>The way of generating inputs is different, ContractFuzzer and Echidna generate test cases based on a set of predefined parameter values, and fail to cover deeper paths that expose some vulnerabilities. sFuzz has guided input generation based on a genetic algorithm to iteratively improve its branch coverage. ILF generates input based on AI, using neural networks.</p>
<p>All in all, only Smartian, ILF, and Echidna at the end show the path how we could reproduce the bug. As Smartian covers more bug classes than ILF, shown in bellow Figure<sup>5</sup> , the focus in this research will be on Smartian and Echidna.</p>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/FuzzTools.png" title="" alt="Comparison of fuzz tools" data-align="center"></p>
</section>
<section id="results-discussion" class="level1">
<h1>Results &amp; Discussion</h1>
<p>All examples are run on MacOS Big Sur, version 11.6, processor 2,6 GHz 6-Core Intel Core i7 and 16GB of memory. As there is no upper bound on how long Echidna can run, but the goal is to find a bug in up to 5 minutes.<sup>6</sup> Configuration for Smartian test timeout is set up to 5 minutes.</p>
<p>Let’s first show and discuss few motivating smart contract examples:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1">contract MotivationExample {</span>
<span id="cb1-2">    <span class="kw" style="color: #00769E;">function</span> <span class="fu" style="color: #4758AB;">f</span>(int256 a<span class="op" style="color: #5E5E5E;">,</span> int256 b<span class="op" style="color: #5E5E5E;">,</span> int256 c) <span class="kw" style="color: #00769E;">public</span> pure <span class="fu" style="color: #4758AB;">returns</span> (int256) {</span>
<span id="cb1-3">        int256 d <span class="op" style="color: #5E5E5E;">=</span> b <span class="op" style="color: #5E5E5E;">+</span> c<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-4">        <span class="cf" style="color: #00769E;">if</span> (d <span class="op" style="color: #5E5E5E;">&lt;</span> <span class="dv" style="color: #AD0000;">1</span>) {</span>
<span id="cb1-5">            <span class="cf" style="color: #00769E;">if</span> (b <span class="op" style="color: #5E5E5E;">&lt;</span> <span class="dv" style="color: #AD0000;">3</span>) {</span>
<span id="cb1-6">                <span class="cf" style="color: #00769E;">return</span> <span class="dv" style="color: #AD0000;">1</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-7">            }</span>
<span id="cb1-8">            <span class="cf" style="color: #00769E;">if</span> (a <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">42</span>) {</span>
<span id="cb1-9">                <span class="fu" style="color: #4758AB;">assert</span>(<span class="kw" style="color: #00769E;">false</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-10">                <span class="cf" style="color: #00769E;">return</span> <span class="dv" style="color: #AD0000;">2</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-11">            }</span>
<span id="cb1-12">            <span class="cf" style="color: #00769E;">return</span> <span class="dv" style="color: #AD0000;">3</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-13">        } <span class="cf" style="color: #00769E;">else</span> {</span>
<span id="cb1-14">            <span class="cf" style="color: #00769E;">if</span> (c <span class="op" style="color: #5E5E5E;">&lt;</span> <span class="dv" style="color: #AD0000;">42</span>) {</span>
<span id="cb1-15">                <span class="cf" style="color: #00769E;">return</span> <span class="dv" style="color: #AD0000;">4</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-16">            }</span>
<span id="cb1-17">            <span class="cf" style="color: #00769E;">return</span> <span class="dv" style="color: #AD0000;">5</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-18">        }</span>
<span id="cb1-19">    }</span>
<span id="cb1-20">}</span></code></pre></div>
<p>Very fast both Smartian and Echidna find assertion failure in above smart contract, results with counterexample and information how to reproduce transaction are show in next Figures(Figure1 and Figure2):</p>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/motivation/example3/motivation_example_smartian.png" title="Smartian replayable test case" alt="Smartian" data-align="center"></p>
<p>Figure1 : Smartian replayable test case</p>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/motivation/example3/motivation_example_echidna.png" title="Echidna replayable test case" alt="Echidna" data-align="center"></p>
<p>Figure2 : Echidna replayable test case</p>
<p>The next two examples have some more complex math:</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1">contract MotivationExample {</span>
<span id="cb2-2">    bool <span class="kw" style="color: #00769E;">private</span> value_found<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-3"></span>
<span id="cb2-4">    <span class="kw" style="color: #00769E;">function</span> <span class="fu" style="color: #4758AB;">f</span>(uint256 a<span class="op" style="color: #5E5E5E;">,</span> uint256 b<span class="op" style="color: #5E5E5E;">,</span> uint256 c<span class="op" style="color: #5E5E5E;">,</span> uint256 d) <span class="kw" style="color: #00769E;">public</span> {</span>
<span id="cb2-5">        <span class="pp" style="color: #AD0000;">require</span>(a <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">42</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-6">        <span class="pp" style="color: #AD0000;">require</span>(b <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">129</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-7">        <span class="pp" style="color: #AD0000;">require</span>(c <span class="op" style="color: #5E5E5E;">==</span> d<span class="op" style="color: #5E5E5E;">+</span><span class="dv" style="color: #AD0000;">333</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-8">        value_found <span class="op" style="color: #5E5E5E;">=</span> <span class="kw" style="color: #00769E;">true</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-9">        <span class="fu" style="color: #4758AB;">assert</span>(value_found <span class="op" style="color: #5E5E5E;">==</span> <span class="kw" style="color: #00769E;">false</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-10">    }</span>
<span id="cb2-11">}</span></code></pre></div>
<p>Above one, the inputs must meet three requirements, and to the equality. Smartian and Echidna test it, and at bellow Figures(Figure3 and Figure4) are results:</p>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/motivation/example1/motivation_example_smartian.png" title="Smartian replayable test case" alt="Smartian" data-align="center"></p>
<p>Figure3 : Smartian replayable test case</p>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/motivation/example1/motivation_example_echidna.png" title="Echidna failed to find assertion" alt="Echidna" data-align="center"></p>
<p>Figure4 : Echidna failed to find assertion</p>
<p>Smartian quickly found assertion failure and counterexample, while Echidna failed to find one. Take a look at hardest motivation example and result from fuzzers:</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1">contract MotivationExample {</span>
<span id="cb3-2">    uint256 <span class="kw" style="color: #00769E;">private</span> stateA<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-3">    uint256 <span class="kw" style="color: #00769E;">private</span> stateB<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-4">    uint256 CONST <span class="op" style="color: #5E5E5E;">=</span> <span class="dv" style="color: #AD0000;">32</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-5"></span>
<span id="cb3-6">    <span class="kw" style="color: #00769E;">function</span> <span class="fu" style="color: #4758AB;">f</span>(uint256 x) <span class="kw" style="color: #00769E;">public</span> {</span>
<span id="cb3-7">      stateA <span class="op" style="color: #5E5E5E;">=</span> x<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-8">    }</span>
<span id="cb3-9"></span>
<span id="cb3-10">    <span class="kw" style="color: #00769E;">function</span> <span class="fu" style="color: #4758AB;">g</span>(uint256 y) <span class="kw" style="color: #00769E;">public</span>{</span>
<span id="cb3-11">      <span class="cf" style="color: #00769E;">if</span> (stateA <span class="op" style="color: #5E5E5E;">%</span> CONST <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">1</span>) {</span>
<span id="cb3-12">        stateB <span class="op" style="color: #5E5E5E;">=</span> y <span class="op" style="color: #5E5E5E;">-</span> <span class="dv" style="color: #AD0000;">10</span><span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-13">      }</span>
<span id="cb3-14">    }</span>
<span id="cb3-15"></span>
<span id="cb3-16">    <span class="kw" style="color: #00769E;">function</span> <span class="fu" style="color: #4758AB;">h</span>() <span class="kw" style="color: #00769E;">public</span> view {</span>
<span id="cb3-17">      <span class="cf" style="color: #00769E;">if</span> (stateB <span class="op" style="color: #5E5E5E;">==</span> <span class="dv" style="color: #AD0000;">62</span>) { </span>
<span id="cb3-18">        <span class="fu" style="color: #4758AB;">bug</span>()<span class="op" style="color: #5E5E5E;">;</span> </span>
<span id="cb3-19">      }</span>
<span id="cb3-20">    }</span>
<span id="cb3-21"></span>
<span id="cb3-22">    <span class="kw" style="color: #00769E;">function</span> <span class="fu" style="color: #4758AB;">bug</span>() <span class="kw" style="color: #00769E;">private</span> pure {</span>
<span id="cb3-23">      <span class="fu" style="color: #4758AB;">assert</span>(<span class="kw" style="color: #00769E;">false</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb3-24">    }</span>
<span id="cb3-25">}</span></code></pre></div>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/motivation/example2/motivation_example_smartian.png" title="Smartian replayable test case" alt="Smartian" data-align="center"></p>
<p>Figure5 : Smartian replayable test case</p>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/motivation/example2/motivation_example_echidna.png" title="Echidna failed to find assertion" alt="Echidna" data-align="center"></p>
<p>Figure6 : Echidna failed to find assertion</p>
<p>Again, Smartian quickly finds assertion failure, while Echidna fails. The reason for failure is due to the way it generates inputs. Echidna is not smart to go in-depth when making input seeds and figure out the values in the deeper branches.</p>
<p>Indeed, there is a way for Echidna to find assertion failure in the above examples, solution is in the configuration file.</p>
<p>Echidna has a YAML configuration file, with configurable parameters, that can be turned on or off during the test. If <code>config.yaml</code> is not listed, the <a href="https://github.com/crytic/echidna/blob/master/tests/solidity/basic/default.yaml">default YAML</a> configuration file is called.<sup>7</sup> Some of configuration parameters enable to blacklist function, compute maximum gas usage, the maximum number of transactions sequences to generate, number of test sequences to run, prefix for boolean functions that are properties to be checked, contract deployer address. Also it is possible to define set of addresses transactions originate from along with default balance for addresses. In case we have a complex contract, and we need to initialize the blockchain with some data -&gt; tool Etheno helps here<sup>8</sup> , after Etheno finishes the initialization JSON file is created, that is set as initialization inside configuration file. Additionally, if our contract uses some framework, for example, Hardhat or Truffle, Echidna then use crytic compile, and build directory of the framework is sent through crytic arguments inside Echidna configuration file.</p>
<p>Back to the above example, to find assertion failure, it is enough inside configuration file to set corpus directory. After first run, inside the corpus directory we could see the generated input for contract properties, now is enough to modify the input to use suitable parameters that will cause assertion failure.</p>
<p>Although Smartian beat Echidna in the above examples, the logical question, that arises, is what are the advantages of Echidna and why would we use Echidna rather than Smartian?</p>
<p>Echidna’s advantage are invariants, Invariants are Solidity functions that can represent any incorrect state that contract can have, each invariant must be:</p>
<ul>
<li>Public method that has no argument</li>
<li>Return true if it is successful</li>
</ul>
<p>or:</p>
<ul>
<li>Public method that can have an argument</li>
<li>Use assert in function</li>
</ul>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/The-Echidna-architecture.png" title="Architecture of Echdina" alt="ArchitectureEchidna" data-align="center"></p>
<p>Figure7 : Architecture of Echdina</p>
<p>Architecture<sup>9</sup> is divided into preprocessing and fuzzing campaigns. In the preprocessing step, the static analyzer tool Slither<sup>10</sup> is used with the purpose to find useful constants and functions for effective testing. In the fuzzing campaign step, using contract ABI(Application binary interface) the random transactions are generated, and also any previous transactions from the corpus are included. In case the vulnerability is detected, a counterexample is automatically minimized to the smallest and simplest sequence of transactions that cause failure.</p>
<p>Running Echidna:</p>
<p><code>$ echidna-test contract.sol --constract TEST --config config.yaml</code>,</p>
<p>or if Truffle or Hardhat is used:</p>
<p><code>$ echidna-test . contract.sol --constract TEST --config config.yaml</code></p>
<p>Echidna can be run from the docker, the official image of the current 2.0.0 version is trailofbits/echidna. Inside docker, default version of solidity compiler is 0.5.7, so if we want to test contracts in another version we need to install solc-select. If the preferred method is to not worry about how to install additional tools, there is a docker image trailofbits/eth-security-toolbox, but currently there ecidna version is 1.7.2.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Although Smartian is better at generating input, what should be noted is that Smartian still doesn’t have support for solc 0.8.x or greater. All examples from the section Results &amp; Discussion have been tested with solc 0.4.25. For an experiment, if you take <a href="../assets/ERFC-42/research_examples/smartian_banchmark/IB/0.4.25/IB.sol">IB.sol</a> from Smartian benchmark examples,<sup>11</sup> and adapt it to work with solidity version 0.8.9, Smartian will fail to find Integer Bug, but Echidna will find it. If you take a look at comparison of fuzz tools in Goals &amp; Methodology that in the previous version Echidna was not able to found these bugs, as the integer overflow/underflow is one of the features in Echidna 2.0.0 for solc 0.8.x or greater. In Appendix at Figure11 and Figure12 is shown Smartian output, and in Figure13 is shown Echidna output.</p>
<p>In general, Echidna and Smartian together cover bug classes: Assertion Failure and Integer Bug. Some comparison examples between Echidna 2.0.0, Smartian solc 0.4.25 and Smartian solc 0.8.9 are in <a href="../assets/ERFC-42/research_examples/">research_examples</a>.</p>
<p>Echidna Assertion allows us to manage what property should test along with the input range value of testing property arguments, in contrary using explicit property we are not sure which function will be checked and which arguments should be used to call test property, explicit property check all method that is not private or internal.</p>
<p>When asked which tool of the two to use, the simple answer is both. Both tools are promising. They cover different classes of problems and the use of both tools for testing smart contracts reduces the chance that our contract has potential flaws. Echidna is under active development, so it is reasonable that it is buggy. But, they work hard to reply &amp; fix each issue.</p>
<p>The Echidna coverage report is a little bit confused, one is shown at Figure8. Some suggestion is to add some styled report(<a href="https://twitter.com/dapptools/status/1435973810545729536">example</a>) and the legend table of symbol meaning:</p>
<table class="table">
<colgroup>
<col style="width: 13%">
<col style="width: 86%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Line marker</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">’*’</td>
<td style="text-align: left;">If an execution ended with a STOP</td>
</tr>
<tr class="even">
<td style="text-align: center;">r</td>
<td style="text-align: left;">If an execution ended with a REVERT</td>
</tr>
<tr class="odd">
<td style="text-align: center;">o</td>
<td style="text-align: left;">If an execution ended with an out-of-gas error</td>
</tr>
<tr class="even">
<td style="text-align: center;">e</td>
<td style="text-align: left;">If an execution ended with any other error (zero division, assertion failure, etc)</td>
</tr>
</tbody>
</table>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/motivation/example2/coverage_echidna.png" title="Echidna coverage" alt="Echidna_coverage" data-align="center"></p>
<p>Figure8 : Echidna coverage</p>
<p>UI for both tools should be improved, it would be nice to display emitted events. And, Smartian output could color counterexample and found bugs. The current UI is shown in the bellow Figures.</p>
<dl>
<dt><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/AF/0.4.25/0.4.25_smartian_af.png" title="" alt="Smartian_UI" data-align="center">Figure9</dt>
<dd>
Smartian output
</dd>
</dl>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/AF/0.8.9/0.8.9_echidna_af.png" title="Echidna output" alt="Evdhidna_UI" data-align="center"></p>
<p>Figure10 : Echidna output</p>
<p>It would be nice to have integration with Remix IDE, which will help with debugging.</p>
</section>
<section id="appendices" class="level1">
<h1>Appendices</h1>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/smartian_banchmark/IB/0.4.25/0.4.25_smartain_ib.png" title="Smartian found Integer Bug with 0.4.25" alt="IB_0.4.25" data-align="center"></p>
<p>Figure11 : Smartian found Integer Bug with 0.4.25</p>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/smartian_banchmark/IB/0.8.9/0.8.9_smartian_ib.png" title="Smartian not found Integer Bug with 0.8.9" alt="IB_0.8.9" data-align="center"></p>
<p>Figure12 : Smartian not found Integer Bug with 0.8.9</p>
<p><img src="https://3327.io/documents/research/assets/ERFC-42/research_examples/smartian_banchmark/IB/echidna/echidna_0.8.9.png" title="Echidna found Integer Bug with 0.8.9" alt="IB_Echidna" data-align="center"></p>
<p>Figure13 : Echidna found Integer Bug with 0.8.9</p>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-BuildingsecurecontractsWorkflowMd" class="csl-entry">
‘Building-Secure-Contracts/Workflow.md at Master <embed src="https://latex.codecogs.com/svg.latex?%5Ccdot" title="\cdot" class="img-fluid"> Crytic/Building-Secure-Contracts’, <em>GitHub</em> &lt;<a href="https://github.com/crytic/building-secure-contracts" class="uri">https://github.com/crytic/building-secure-contracts</a>&gt; [accessed 14 February 2022]
</div>
<div id="ref-choiSMARTIANEnhancingSmart2021" class="csl-entry">
Choi, Jaeseung, Doyeon Kim, Soomin Kim, Gustavo Grieco, Alex Groce, and Sang Kil Cha, ‘SMARTIAN: Enhancing Smart Contract Fuzzing with Static and Dynamic Data-Flow Analyses’, in <em>2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em> (Melbourne, Australia: IEEE, 2021), pp.&nbsp;227–39 &lt;https://doi.org/<a href="https://doi.org/10.1109/ASE51524.2021.9678888">10.1109/ASE51524.2021.9678888</a>&gt;
</div>
<div id="ref-Etheno2022" class="csl-entry">
‘Etheno’ (Crytic, 2022) &lt;<a href="https://github.com/crytic/etheno" class="uri">https://github.com/crytic/etheno</a>&gt; [accessed 28 February 2022]
</div>
<div id="ref-foxleyHarvestFinance24M2020" class="csl-entry">
Foxley, William, ‘Harvest Finance: $24m Attack Triggers $570m ’Bank Run’ in Latest DeFi Exploit’, 2020 &lt;<a href="https://www.coindesk.com/tech/2020/10/26/harvest-finance-24m-attack-triggers-570m-bank-run-in-latest-defi-exploit/" class="uri">https://www.coindesk.com/tech/2020/10/26/harvest-finance-24m-attack-triggers-570m-bank-run-in-latest-defi-exploit/</a>&gt; [accessed 11 February 2022]
</div>
<div id="ref-griecoEchidnaEffectiveUsable2020" class="csl-entry">
Grieco, Gustavo, Will Song, Artur Cygan, Josselin Feist, and Alex Groce, ‘Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts’, in <em>ISSTA 2020</em>, 2020
</div>
<div id="ref-siegelUnderstandingDAOAttack2016" class="csl-entry">
Siegel, David, ‘Understanding The DAO Attack’, 2016 &lt;<a href="https://www.coindesk.com/learn/2016/06/25/understanding-the-dao-attack/" class="uri">https://www.coindesk.com/learn/2016/06/25/understanding-the-dao-attack/</a>&gt; [accessed 11 February 2022]
</div>
<div id="ref-SlitherSoliditySource2022" class="csl-entry">
‘Slither, the Solidity Source Analyzer’ (Crytic, 2022) &lt;<a href="https://github.com/crytic/slither" class="uri">https://github.com/crytic/slither</a>&gt; [accessed 11 February 2022]
</div>
<div id="ref-ParityWalletHack2017" class="csl-entry">
‘The Parity Wallet Hack Explained’, <em>OpenZeppelin Blog</em>, 2017 &lt;<a href="https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7/" class="uri">https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7/</a>&gt; [accessed 11 February 2022]
</div>
</div></section><section class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>‘The Parity Wallet Hack Explained’, <em>OpenZeppelin Blog</em>, 2017 &lt;&lt;https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7/&gt;&gt; [accessed 11 February 2022].↩︎</p></li>
<li id="fn2"><p>David Siegel, ‘Understanding The DAO Attack’, 2016 &lt;&lt;https://www.coindesk.com/learn/2016/06/25/understanding-the-dao-attack/&gt;&gt; [accessed 11 February 2022].↩︎</p></li>
<li id="fn3"><p>William Foxley, ‘Harvest Finance: $24m Attack Triggers $570m ’Bank Run’ in Latest DeFi Exploit’, 2020 &lt;&lt;https://www.coindesk.com/tech/2020/10/26/harvest-finance-24m-attack-triggers-570m-bank-run-in-latest-defi-exploit/&gt;&gt; [accessed 11 February 2022].↩︎</p></li>
<li id="fn4"><p>‘Building-Secure-Contracts/Workflow.md at Master <embed src="https://latex.codecogs.com/svg.latex?%5Ccdot" title="\cdot" class="img-fluid"> Crytic/Building-Secure-Contracts’, <em>GitHub</em> &lt;&lt;https://github.com/crytic/building-secure-contracts&gt;&gt; [accessed 14 February 2022].↩︎</p></li>
<li id="fn5"><p>Jaeseung Choi and others, ‘SMARTIAN: Enhancing Smart Contract Fuzzing with Static and Dynamic Data-Flow Analyses’, in <em>2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em> (Melbourne, Australia: IEEE, 2021), pp.&nbsp;227–39 &lt;https://doi.org/[10.1109/ASE51524.2021.9678888](https://doi.org/10.1109/ASE51524.2021.9678888)&gt;.↩︎</p></li>
<li id="fn6"><p>Gustavo Grieco and others, ‘Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts’, in <em>ISSTA 2020</em>, 2020.↩︎</p></li>
<li id="fn7"><p><strong>CryticEchidnaEthereum?</strong>↩︎</p></li>
<li id="fn8"><p>‘Etheno’ (Crytic, 2022) &lt;&lt;https://github.com/crytic/etheno&gt;&gt; [accessed 28 February 2022].↩︎</p></li>
<li id="fn9"><p>Grieco and others.↩︎</p></li>
<li id="fn10"><p>‘Slither, the Solidity Source Analyzer’ (Crytic, 2022) &lt;&lt;https://github.com/crytic/slither&gt;&gt; [accessed 11 February 2022].↩︎</p></li>
<li id="fn11"><p><strong>Smartian2022?</strong>↩︎</p></li>
</ol>
</section></div> ]]></description>
  <guid>https://3327.io/documents/research/posts/ERFC-42.gfm.html</guid>
  <pubDate>Wed, 16 Feb 2022 23:00:00 GMT</pubDate>
  <media:content url="https://latex.codecogs.com/svg.latex?%5Ccdot " medium="image"/>
</item>
</channel>
</rss>
